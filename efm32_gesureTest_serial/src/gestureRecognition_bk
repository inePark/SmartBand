#include "em_device.h"
#include "em_chip.h"
#include "em_usart.h"
#include "em_cmu.h"
#include "em_gpio.h"
#include "em_i2c.h"
#include "swCfg.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define WMA_FACTOR	3
//#undef WMA_FACTOR
#define WEIGHT	0.8
#undef WEIGHT
#define NORMALIZATION_FACTOR INT16_MAX

int16_t SENSOR [AXIS_NUM][SAMPLE_NUM];
#ifdef WMA_FACTOR
	#define WMA_SAMPLE_NUM	SAMPLE_NUM - WMA_FACTOR + 1
	int16_t WMA_SENSOR [AXIS_NUM][WMA_SAMPLE_NUM];
	int16_t WMA_temp [AXIS_NUM][WMA_SAMPLE_NUM];

#endif
#define CROSS_FACTOR	5
int8_t WEIGHTED_AXIS [6];

#define NUM_OF_DB	4

enum sensors_	{
	ACC_X,
	ACC_Y,
	ACC_Z,
	GY_X,
	GY_Y,
	GY_Z
};

int corr_int [AXIS_NUM][AXIS_NUM];



///////////////////////////////////////////////////////////////////////
void deriveCorrelation ()	{
///////////////////////////////////////////////////////////////////////
// A factor: The array of sensor data
// Return: NULL
//////////////////////////////////////////////////////////////////////

	float cov [AXIS_NUM][AXIS_NUM];
	float corr [AXIS_NUM][AXIS_NUM];
	float average [] = {0,0,0,0,0,0};
	int nLoop, nLoop2, nLoop3;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			average [nLoop] += SENSOR [nLoop][nLoop2];
		} //for nLoop2
		average [nLoop] /= SAMPLE_NUM;
	} //for nLoop



	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			cov [nLoop][nLoop2] = corr [nLoop][nLoop2] = corr_int[nLoop][nLoop2] = 0;
			for (nLoop3 = 0; nLoop3 < SAMPLE_NUM; nLoop3 ++)	{
				cov [nLoop][nLoop2] += (SENSOR [nLoop][nLoop3] - average [nLoop]) * (SENSOR [nLoop2][nLoop3] - average [nLoop2]);
			} // for nLoop3
			cov [nLoop][nLoop2] /= SAMPLE_NUM;

		} // for nLoop2
	} //for nLoop


	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = nLoop+1; nLoop2 < AXIS_NUM; nLoop2 ++)	{

			if (cov [nLoop][nLoop] * cov [nLoop2][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov [nLoop][nLoop] * cov [nLoop2][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;

			if ((corr [nLoop][nLoop2] < 0.5) && (corr [nLoop][nLoop2] > -0.5))	{	//filtering
				corr [nLoop][nLoop2] = 0;
			} //if
			else	{
				corr_int [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *100);
			}
		} //for nLoop2
	} //for nLoop

/*
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			printf ("%d\t", corr_int [nLoop][nLoop2] );
		}
		printf ("\n");
	}
	printf ("\n");
*/
} //function calculatCorrelation

//////////////////////////////////////////////////////////////////////
int compareSelfCorrleation (int db_id)	{
///////////////////////////////////////////////////////////////////////
// A factor: A DB id among 2, 3, 4, 5, 6, 7, 8, 9, 14, 15
// Return: detected DB id
//////////////////////////////////////////////////////////////////////

	int avg_gap [2] = {0,0};
	int result_ = 0;
	int nLoop, nLoop2, nLoop3;
	int filter_count = 0;
	float MIN = 10000.0;


	int total_db_count [2] = {22, 27};

	int db_corr [2][AXIS_NUM][AXIS_NUM] = {
			{		//for sensor1, CLOCK
					{0, 61, 00, 91, 69, 00 },
					{00, 00, 04, 59, 75, 00 },
					{00, 00, 00, 68, 25, 00 },
					{00, 00, 00, 00, 78, 00 },
					{00, 00, 00, 00, 00, 00 },
					{00, 00, 00, 00, 00, 00 },
				},

				{		//for sensor1, ANTI-CLOCK
					{00, 81, 59, -91, -83, -67 },
					{00, 00, -31, -81, -81, -91 },
					{00, 00, 00, -07, 55, -96 },
					{00, 00, 00, 00, 86, 98 },
					{00, 00, 00, 00, 00, 72 },
					{00, 00, 00, 00, 00, 00 },
				}
		};
	int db_count [2][AXIS_NUM][AXIS_NUM]= {
			{		//for sensor1, CLOCK
				{0, 3, 0, 21, 13, 0 },
				{0, 0, 4, 14, 16, 0 },
				{0, 0, 0, 6, 8, 0 } ,
				{0, 0, 0, 0, 16, 0 },
				{0, 0, 0, 0, 0, 0 },
				{0, 0, 0, 0, 0, 0 },
			},

			{		//for sensor1, ANTI-CLOCK
				{0, 18, 5, 24, 27, 1 },
				{0, 0, 12, 20, 25, 1 },
				{0, 0, 0, 4, 10, 1 },
				{0, 0, 0, 0, 27, 1 },
				{0, 0, 0, 0, 0, 1 },
				{0, 0, 0, 0, 0, 0 },
			},

	};

	for (nLoop = 0; nLoop < 2; nLoop ++)	{

		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			for (nLoop3 = nLoop2 + 1; nLoop3 < AXIS_NUM; nLoop3 ++)	{

				if ((db_count [nLoop][nLoop2][nLoop3] * 5) >  total_db_count [nLoop])	{
					avg_gap [nLoop] += abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]);
					filter_count ++;
					//printf ("%d\t", abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]));
				}


			} //for nLoop3
		} //for nLoop2

		if (filter_count == 0)
			filter_count ++;


		avg_gap [nLoop] /= filter_count;

		filter_count = 0;

		if ((avg_gap [nLoop] != 0) && (MIN > avg_gap [nLoop]))	{
			MIN = avg_gap [nLoop];
		}

	} //for nLoop


	if (avg_gap [0] < avg_gap [1])	{
		result_ = (db_id % 2 == 1) ? (db_id - 1) : (db_id);		//CLOCK
	}
	else	{
		result_ = (db_id % 2 == 1) ? (db_id) : (db_id + 1);		//ANTI-CLOCK
	}

	//printf ("<%d vs. %d> corr result is %d \n",  avg_gap[0],avg_gap[1], result_);

	return result_;
}


#ifdef WMA_FACTOR
void weightedMovingAverage (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{
	int nLoop, nLoop2, nLoop3;
	int16_t temp_avr;

	memset (WMA_SENSOR, '\0', sizeof(WMA_SENSOR));

	//printf ("<< WMA\n");
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < (SAMPLE_NUM - WMA_FACTOR + 1); nLoop2 ++)	{
			temp_avr = 0;
#ifndef WEIGHT
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR; nLoop3 ++)	{
				temp_avr +=  sensor [nLoop][nLoop2 + nLoop3];
			}
			WMA_SENSOR [nLoop][nLoop2] = temp_avr / WMA_FACTOR;

#else
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR-1; nLoop3 ++)	{
				temp_avr +=  sensor [nLoop][nLoop2 + nLoop3];
			}
			temp_avr *= (1-WEIGHT);
			temp_avr += (WEIGHT * sensor [nLoop][nLoop2 + nLoop3]);
			WMA_SENSOR [nLoop][nLoop2] = temp_avr;
#endif
			//printf ("(%d)%d  ", nLoop2, WMA_SENSOR [nLoop][nLoop2]);
		}
		//printf ("\n");
	}
	//printf ("\n");
}
#endif



void compareOtherCorrelation (int arrayLen, int flag_)	{

	float db_sample [NUM_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
			{ //right
				{0.0294 ,0.0424 ,0.0824 ,0.1944 ,0.3684 ,0.4487 ,0.3406 ,0.0137 ,-0.3080 ,-0.4736 ,-0.4514 ,-0.2904 ,-0.0787 ,0.1341 ,0.2938 ,0.3142 ,0.2693 ,0.1737 },
				{-0.0102 ,-0.0143 ,-0.0182 ,-0.0350 ,0.0109 ,0.0332 ,-0.0101 ,-0.1582 ,-0.2743 ,-0.2864 ,-0.1941 ,-0.1510 ,-0.1038 ,-0.1134 ,-0.0419 ,-0.0167 ,0.0122 ,-0.0149},
				{0.5415 ,0.5232 ,0.5276 ,0.5076 ,0.5611 ,0.6911 ,0.7003 ,0.6202 ,0.4863 ,0.5229 ,0.5816 ,0.5577 ,0.4785 ,0.4868 ,0.5139 ,0.5559 ,0.5236 ,0.5170},
				{-0.0011 ,-0.0004 ,-0.0028 ,-0.0006 ,-0.0053 ,-0.0047 ,-0.0190 ,-0.0363 ,-0.0403 ,-0.0171 ,0.0126 ,0.0246 ,0.0103 ,-0.0011 ,-0.0146 ,-0.0072 ,-0.0038 ,0.0054},
				{0.0005 ,0.0006 ,0.0009 ,-0.0022 ,-0.0078 ,-0.0269 ,-0.0528 ,-0.0509 ,-0.0290 ,0.0188 ,0.0263 ,0.0092 ,0.0085 ,0.0252 ,0.0561 ,0.0406 ,0.0162 ,-0.0102},
				{0.0022 ,0.0023 ,0.0022 ,0.0091 ,-0.0059 ,-0.0512 ,-0.1178 ,-0.1485 ,-0.1217 ,-0.0594 ,-0.0043 ,0.0301 ,0.0651 ,0.0944 ,0.1054 ,0.0862 ,0.0589 ,0.0346},

			},
			{ //left
				{0.0340 ,0.0369 ,-0.0331 ,-0.2630 ,-0.4771 ,-0.4155 ,-0.0738 ,0.3171 ,0.5003 ,0.5474 ,0.4843 ,0.3700 ,0.2244 ,0.0899 ,-0.0367 ,-0.1415 ,-0.1714 ,-0.1286 },
				{0.0030 ,0.0004 ,0.0255 ,0.0209 ,-0.1178 ,-0.2858 ,-0.3288 ,-0.2000 ,-0.0588 ,0.0396 ,0.0543 ,0.0419 ,-0.0547 ,-0.0579 ,-0.0589 ,-0.0354 ,-0.0518 ,-0.0313},
				{0.5447 ,0.5324 ,0.5331 ,0.5564 ,0.6240 ,0.6779 ,0.5487 ,0.4812 ,0.4368 ,0.5017 ,0.4597 ,0.4428 ,0.4542 ,0.5141 ,0.5608 ,0.6068 ,0.6359 ,0.6067 },
				{-0.0055 ,-0.0042 ,-0.0074 ,-0.0099 ,-0.0038 ,0.0019 ,-0.0011 ,0.0118 ,0.0176 ,0.0192 ,0.0033 ,-0.0024 ,0.0088 ,0.0041 ,-0.0053 ,-0.0245 ,-0.0226 ,-0.0148},
				{0.0007 ,0.0009 ,-0.0015 ,-0.0139 ,-0.0188 ,0.0099 ,0.0389 ,0.0130 ,-0.0100 ,-0.0161 ,0.0103 ,-0.0027 ,-0.0350 ,-0.0560 ,-0.0576 ,-0.0404 ,-0.0182 ,0.0048 },
				{0.0089 ,0.0049 ,-0.0001 ,-0.0047 ,0.0319 ,0.1076 ,0.1808 ,0.1924 ,0.1432 ,0.0776 ,0.0057 ,-0.0560 ,-0.0986 ,-0.1155 ,-0.1200 ,-0.1088 ,-0.0780 ,-0.0358 }

			},
			{ //front
				{0.0969 ,0.1261 ,0.0328 ,-0.0320 ,-0.0234 ,0.0704 ,0.0601 ,0.0402 ,0.0189 ,0.0143 ,-0.0068 ,-0.0139 ,-0.0186 ,-0.0169 ,-0.0188 ,-0.0185 ,-0.0168 ,-0.0149 },
				{0.0940 ,-0.1825 ,-0.4067 ,-0.4740 ,-0.4353 ,-0.3265 ,-0.1829 ,0.0766 ,0.3170 ,0.4392 ,0.3957 ,0.2728 ,0.1597 ,0.0837 ,0.0532 ,0.0331 ,0.0330 ,0.0390 },
				{0.0096 ,-0.0088 ,-0.0612 ,0.0496 ,0.0205 ,0.0845 ,-0.0242 ,-0.0481 ,-0.0354 ,0.0214 ,0.0533 ,0.0295 ,0.0133 ,-0.0156 ,-0.0056 ,0.0015 ,0.0100 ,0.0017 },
				{0.0401 ,0.0252 ,-0.0246 ,-0.0136 ,-0.0201 ,0.0075 ,-0.0170 ,-0.0338 ,-0.0525 ,-0.0533 ,-0.0239 ,-0.0033 ,0.0093 ,0.0033 ,-0.0018 ,-0.0018 ,0.0006 ,-0.0002},
				{0.0003 ,0.0399 ,0.0697 ,0.0313 ,-0.0005 ,-0.0351 ,-0.0149 ,-0.0194 ,-0.0058 ,0.0023 ,0.0123 ,0.0100 ,0.0061 ,0.0028 ,0.0003 ,-0.0022 ,0.0005 ,0.0015 },
				{-0.0444 ,-0.0733 ,-0.0714 ,-0.0137 ,0.0385 ,0.0809 ,0.0756 ,0.0711 ,0.0286 ,-0.0081 ,-0.0313 ,-0.0243 ,-0.0122 ,-0.0007 ,0.0036 ,0.0041 ,0.0034 ,0.0021 }

			},
			{// back
				{-0.0193 ,-0.0554 ,-0.0927 ,-0.1154 ,-0.0909 ,-0.0266 ,0.0347 ,0.0654 ,0.0647 ,0.0414 ,0.0121 ,0.0158 ,0.0295 ,0.0527 ,0.0534 ,0.0438 ,0.0343 ,0.0316 },
				{0.1203 ,0.2916 ,0.4127 ,0.3985 ,0.3370 ,0.2472 ,0.1262 ,-0.0246 ,-0.1566 ,-0.2351 ,-0.2290 ,-0.1673 ,-0.0867 ,-0.0265 ,0.0058 ,0.0273 ,0.0341 ,0.0345},
				{0.5738 ,0.6149 ,0.5962 ,0.5149 ,0.4913 ,0.4742 ,0.4719 ,0.4682 ,0.5143 ,0.5629 ,0.5830 ,0.5817 ,0.5402 ,0.5361 ,0.5353 ,0.5389 ,0.5264 ,0.5110 },
				{-0.0524 ,-0.0584 ,-0.0193 ,0.0274 ,0.0542 ,0.0547 ,0.0403 ,0.0217 ,-0.0026 ,-0.0152 ,-0.0199 ,-0.0134 ,-0.0060 ,0.0030 ,0.0033 ,0.0044 ,0.0033 ,0.0009},
				{0.0434 ,0.0811 ,0.0571 ,-0.0018 ,-0.0650 ,-0.0660 ,-0.0463 ,-0.0211 ,-0.0076 ,0.0026 ,-0.0005 ,0.0011 ,0.0002 ,-0.0020 ,-0.0001 ,0.0017 ,0.0012 ,-0.0006 },
				{0.0017 ,-0.0033 ,-0.0015 ,0.0136 ,0.0366 ,0.0331 ,0.0195 ,-0.0105 ,-0.0231 ,-0.0289 ,-0.0175 ,-0.0063 ,0.0054 ,0.0083 ,0.0067 ,0.0032 ,-0.0003 ,-0.0021 },

			}

	};
	int16_t WMA_SENSOR_local [AXIS_NUM][WMA_SAMPLE_NUM];
	int nLoopLen = 0, nLoopStart = 0;
	float db_average [NUM_OF_DB][AXIS_NUM] = {
			{0.0613, -0.077, 0.5498, -0.0056, 0.0013, -0.001},	//right
			{0.048, -0.0609, 0.5399, 0.0019, -0.0107, 0.0075},	//left
			{0.0155 , -0.0006, 0.0053, -0.0089, 0.0055, 0.0016},	//front
			{0.0044, 0.0616, 0.5353, 0.0014, -0.0013, 0.0019}	//back
	};
	float db_cov [NUM_OF_DB][AXIS_NUM] = {
			{0.0795, 0.0097, 0.004, 0.0003, 0.0008, 0.0055},	//right
			{0.0937, 0.0119, 0.0050, 0.0001, 0.0006, 0.0099},	//left
			{0.0021, 0.0783, 0.0013, 0.0006, 0.0005, 0.0020},	//front
			{0.0033, 0.0425, 0.0019, 0.0010, 0.0013, 0.0003}	//back
	};
	float average [AXIS_NUM] = {0,0,0,0,0,0};
	int nLoop, nLoop2, nLoop3;
	float cov [NUM_OF_DB][AXIS_NUM];
	float cov_self [AXIS_NUM] = {0,0,0,0,0,0};
	float corr [NUM_OF_DB][AXIS_NUM];
	float corr_int_local [NUM_OF_DB][AXIS_NUM];

	memset (cov, '\0', sizeof(cov));
	memset (corr, '\0', sizeof(corr));
	memset (corr_int_local, '\0', sizeof (corr_int_local));


	memset (WMA_SENSOR_local, '\0', sizeof(WMA_SENSOR_local));
	if (flag_ < 1)	{
		nLoopLen = arrayLen;
		nLoopStart = 0;
		memcpy (WMA_SENSOR_local, WMA_temp, sizeof(WMA_SENSOR_local));
	}
	else	{
		nLoopLen = WMA_SAMPLE_NUM;
		nLoopStart = flag_;
		memcpy (WMA_SENSOR_local, WMA_SENSOR, sizeof(WMA_SENSOR_local));

	}


	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{	//average of incoming sensor value
		for (nLoop2 = 0; nLoop2 < nLoopLen ; nLoop2 ++)	{
			average [nLoop] += WMA_SENSOR_local [nLoop][nLoop2];
		} //for nLoop2

		average [nLoop] /= nLoopLen;

	} //for nLoop

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		float temp_float=0;
		for (nLoop2 = nLoopStart; nLoop2 < nLoopLen; nLoop2 ++)	{ //covariance //분자계산
			temp_float = WMA_SENSOR_local [nLoop][nLoop2 - nLoopStart] - average [nLoop];

			for (nLoop3 = 0; nLoop3 < NUM_OF_DB; nLoop3 ++)
				cov [nLoop3][nLoop] += (temp_float * (db_sample [nLoop3][nLoop][nLoop2] - db_average [nLoop3][nLoop]));


			cov_self [nLoop] += (temp_float * temp_float);

		} //for nLoop2

		for (nLoop3 = 0; nLoop3 < NUM_OF_DB; nLoop3 ++)
			cov [nLoop3][nLoop] /= (nLoopLen - nLoopStart);

		cov_self [nLoop] /= (nLoopLen - nLoopStart);
	} // for nLoop

//	printf ("----------------\ncorrelation(len: %d, flag: %d\n", arrayLen, flag_);
	for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{	//correlation. //분모 계산
		int tempSUM = 0;
//		printf ("(%d db)\t", nLoop);
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			if (cov_self [nLoop2] * db_cov [nLoop][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov_self [nLoop2] * db_cov [nLoop][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;
			corr_int_local [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *100);

//			printf ("%d(%d) ", (int)corr_int_local [nLoop][nLoop2], ((int)corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2] / 100));
//			tempSUM += ((int)corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2] / 100);
		} //for nLoop2
//		printf (" --> %d \n", tempSUM);

	} //for nLoop
//	printf ("\n");



}


void normalizingFunction (int16_t sensor [AXIS_NUM][SAMPLE_NUM]){
	int nLoop, nLoop2;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			SENSOR [nLoop][nLoop2] = (int)(((float)sensor [nLoop][nLoop2] / NORMALIZATION_FACTOR) * 100);
		}
	}

}




void crossCorrelation ()	{

	int nLoop, nLoop2;
	memset (WMA_temp, '\0', sizeof(WMA_SAMPLE_NUM));

	for (nLoop = -CROSS_FACTOR; nLoop < 1; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM + nLoop ; nLoop2 ++)	{
			WMA_temp [0][nLoop2] = WMA_SENSOR [0][-nLoop+ nLoop2];
			WMA_temp [1][nLoop2] = WMA_SENSOR [1][-nLoop+ nLoop2];
			WMA_temp [2][nLoop2] = WMA_SENSOR [2][-nLoop+ nLoop2];
			WMA_temp [3][nLoop2] = WMA_SENSOR [3][-nLoop+ nLoop2];
			WMA_temp [4][nLoop2] = WMA_SENSOR [4][-nLoop+ nLoop2];
			WMA_temp [5][nLoop2] = WMA_SENSOR [5][-nLoop+ nLoop2];
			//printf ("[1](%d:%d/%d:%d)  ",-nLoop+ nLoop2,WMA_SENSOR [0][-nLoop+ nLoop2], nLoop2, WMA_temp [0][nLoop2]);
			//printf ("(%d/%d)  ",WMA_SENSOR [0][-nLoop+ nLoop2], WMA_temp [0][nLoop2]);

		}
		//printf ("\n");
		compareOtherCorrelation (WMA_SAMPLE_NUM + nLoop, nLoop);
	}
	for (nLoop = 1; nLoop < CROSS_FACTOR; nLoop ++)	{
		compareOtherCorrelation (WMA_SAMPLE_NUM, nLoop);
	}
}



unsigned char gestureRecognition (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{


	int min_ [AXIS_NUM] = {10000,10000,30000,10000,10000,10000};
	int max_ [AXIS_NUM] = {-10000, -10000,-1000,-1000,-1000,-1000};

	int gaps [AXIS_NUM] = {0,0,0,0,0,0};
	int maxFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	int minFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	int Motionflag_ = 0;
	int nLoop, nLoop2;
	int result_ = 0 ;


	memset (WEIGHTED_AXIS, 2, sizeof (WEIGHTED_AXIS));
	normalizingFunction (sensor);


/*//	printf ("<INPUT>\n");
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			printf ("%d\t", SENSOR [nLoop][nLoop2] );
			printf ("%d\t", sensor [nLoop][nLoop2] );

		}
	}
*/

#ifdef WMA_FACTOR
	weightedMovingAverage (sensor);
#endif

	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{

		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{

			if (min_[nLoop] > SENSOR [nLoop][nLoop2])	{
				min_[nLoop] = SENSOR [nLoop][nLoop2];
				minFlag [nLoop] |= 0x1;
			} else if (max_[nLoop] < SENSOR [nLoop][nLoop2])	{
				max_[nLoop] = SENSOR [nLoop][nLoop2];
				maxFlag [nLoop] |= 0x1;
			}
			minFlag[nLoop] = minFlag[nLoop] << 1;
			maxFlag[nLoop] = maxFlag[nLoop] << 1;

		}

		gaps [nLoop] = max_ [nLoop] - min_ [nLoop];
		if (gaps [nLoop] > 90)	{
			Motionflag_ |= 0x1;
		}
		Motionflag_ = Motionflag_ << 1;

	} //for


	//printf ("flag: %d\n", flag_);

	if (!Motionflag_ )
		result_ = NONE;
	else if (Motionflag_ == 32)	{
		result_ = FRONT;
		WEIGHTED_AXIS [1] = 90;
	}
	else if (Motionflag_ == 64)	{
		result_ = SIDE;
		WEIGHTED_AXIS [0] = 90;
	}
	else if (Motionflag_ == 16)	{
		WEIGHTED_AXIS [2] = 90;
		result_ = UP;
	}
	else	{
		deriveCorrelation ();
		result_ = compareSelfCorrleation (CLOCK);
	}

	printf ("WEIGHTED: <");
	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{
		printf ("%d,", WEIGHTED_AXIS [nLoop]);
	}
	printf (">\n\n");

	crossCorrelation ();



	return result_;

}



=============================================================================

#include "em_device.h"
#include "em_chip.h"
#include "em_usart.h"
#include "em_cmu.h"
#include "em_gpio.h"
#include "em_i2c.h"
#include "swCfg.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define WMA_FACTOR	4
//#undef WMA_FACTOR
#define WEIGHT	0.8
#undef WEIGHT
#define NORMALIZATION_FACTOR INT16_MAX

int16_t SENSOR [AXIS_NUM][SAMPLE_NUM];		//normalized sensor value
#ifdef WMA_FACTOR
	#define WMA_SAMPLE_NUM	SAMPLE_NUM - WMA_FACTOR + 1
	int16_t WMA_SENSOR [AXIS_NUM][WMA_SAMPLE_NUM];	//(weighted) moving average sensor value
	int16_t WMA_temp [AXIS_NUM][WMA_SAMPLE_NUM];

#endif
#define CROSS_FACTOR	5
int8_t WEIGHTED_AXIS [6];

#define NUM_OF_DB	4

enum sensors_	{
	ACC_X,
	ACC_Y,
	ACC_Z,
	GY_X,
	GY_Y,
	GY_Z
};

int corr_int [AXIS_NUM][AXIS_NUM];



///////////////////////////////////////////////////////////////////////
void deriveCorrelation ()	{
///////////////////////////////////////////////////////////////////////
// A factor: The array of sensor data
// Return: NULL
//////////////////////////////////////////////////////////////////////

	float cov [AXIS_NUM][AXIS_NUM];
	float corr [AXIS_NUM][AXIS_NUM];
	float average [] = {0,0,0,0,0,0};
	int nLoop, nLoop2, nLoop3;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			average [nLoop] += SENSOR [nLoop][nLoop2];
		} //for nLoop2
		average [nLoop] /= SAMPLE_NUM;
	} //for nLoop



	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			cov [nLoop][nLoop2] = corr [nLoop][nLoop2] = corr_int[nLoop][nLoop2] = 0;
			for (nLoop3 = 0; nLoop3 < SAMPLE_NUM; nLoop3 ++)	{
				cov [nLoop][nLoop2] += (SENSOR [nLoop][nLoop3] - average [nLoop]) * (SENSOR [nLoop2][nLoop3] - average [nLoop2]);
			} // for nLoop3
			cov [nLoop][nLoop2] /= SAMPLE_NUM;

		} // for nLoop2
	} //for nLoop


	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = nLoop+1; nLoop2 < AXIS_NUM; nLoop2 ++)	{

			if (cov [nLoop][nLoop] * cov [nLoop2][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov [nLoop][nLoop] * cov [nLoop2][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;

			if ((corr [nLoop][nLoop2] < 0.5) && (corr [nLoop][nLoop2] > -0.5))	{	//filtering
				corr [nLoop][nLoop2] = 0;
			} //if
			else	{
				corr_int [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *1000);
			}
		} //for nLoop2
	} //for nLoop

/*
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			printf ("%d\t", corr_int [nLoop][nLoop2] );
		}
		printf ("\n");
	}
	printf ("\n");
*/
} //function calculatCorrelation

//////////////////////////////////////////////////////////////////////
int compareSelfCorrleation (int db_id)	{
///////////////////////////////////////////////////////////////////////
// A factor: A DB id among 2, 3, 4, 5, 6, 7, 8, 9, 14, 15
// Return: detected DB id
//////////////////////////////////////////////////////////////////////

	int avg_gap [2] = {0,0};
	int result_ = 0;
	int nLoop, nLoop2, nLoop3;
	int filter_count = 0;
	float MIN = 10000.0;


	int total_db_count [2] = {22, 27};

	int db_corr [2][AXIS_NUM][AXIS_NUM] = {
			{		//for sensor1, CLOCK
					{0, 61, 00, 91, 69, 00 },
					{00, 00, 04, 59, 75, 00 },
					{00, 00, 00, 68, 25, 00 },
					{00, 00, 00, 00, 78, 00 },
					{00, 00, 00, 00, 00, 00 },
					{00, 00, 00, 00, 00, 00 },
				},

				{		//for sensor1, ANTI-CLOCK
					{00, 81, 59, -91, -83, -67 },
					{00, 00, -31, -81, -81, -91 },
					{00, 00, 00, -07, 55, -96 },
					{00, 00, 00, 00, 86, 98 },
					{00, 00, 00, 00, 00, 72 },
					{00, 00, 00, 00, 00, 00 },
				}
		};
	int db_count [2][AXIS_NUM][AXIS_NUM]= {
			{		//for sensor1, CLOCK
				{0, 3, 0, 21, 13, 0 },
				{0, 0, 4, 14, 16, 0 },
				{0, 0, 0, 6, 8, 0 } ,
				{0, 0, 0, 0, 16, 0 },
				{0, 0, 0, 0, 0, 0 },
				{0, 0, 0, 0, 0, 0 },
			},

			{		//for sensor1, ANTI-CLOCK
				{0, 18, 5, 24, 27, 1 },
				{0, 0, 12, 20, 25, 1 },
				{0, 0, 0, 4, 10, 1 },
				{0, 0, 0, 0, 27, 1 },
				{0, 0, 0, 0, 0, 1 },
				{0, 0, 0, 0, 0, 0 },
			},

	};

	for (nLoop = 0; nLoop < 2; nLoop ++)	{

		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			for (nLoop3 = nLoop2 + 1; nLoop3 < AXIS_NUM; nLoop3 ++)	{

				if ((db_count [nLoop][nLoop2][nLoop3] * 5) >  total_db_count [nLoop])	{
					avg_gap [nLoop] += abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]);
					filter_count ++;
					//printf ("%d\t", abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]));
				}


			} //for nLoop3
		} //for nLoop2

		if (filter_count == 0)
			filter_count ++;


		avg_gap [nLoop] /= filter_count;

		filter_count = 0;

		if ((avg_gap [nLoop] != 0) && (MIN > avg_gap [nLoop]))	{
			MIN = avg_gap [nLoop];
		}

	} //for nLoop


	if (avg_gap [0] < avg_gap [1])	{
		result_ = (db_id % 2 == 1) ? (db_id - 1) : (db_id);		//CLOCK
	}
	else	{
		result_ = (db_id % 2 == 1) ? (db_id) : (db_id + 1);		//ANTI-CLOCK
	}

	//printf ("<%d vs. %d> corr result is %d \n",  avg_gap[0],avg_gap[1], result_);

	return result_;
}


#ifdef WMA_FACTOR
void weightedMovingAverage (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{
	int nLoop, nLoop2, nLoop3;
	int16_t temp_avr;

	memset (WMA_SENSOR, '\0', sizeof(WMA_SENSOR));

	//printf ("<< WMA\n");
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < (SAMPLE_NUM - WMA_FACTOR + 1); nLoop2 ++)	{
			temp_avr = 0;
#ifndef WEIGHT
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR; nLoop3 ++)	{
				temp_avr +=  SENSOR [nLoop][nLoop2 + nLoop3];
			}
			WMA_SENSOR [nLoop][nLoop2] = temp_avr / WMA_FACTOR;

#else
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR-1; nLoop3 ++)	{
				temp_avr +=  sensor [nLoop][nLoop2 + nLoop3];
			}
			temp_avr *= (1-WEIGHT);
			temp_avr += (WEIGHT * sensor [nLoop][nLoop2 + nLoop3]);
			WMA_SENSOR [nLoop][nLoop2] = temp_avr;
#endif
			//printf ("(%d)%d  ", nLoop2, WMA_SENSOR [nLoop][nLoop2]);
		}
		//printf ("\n");
	}
	//printf ("\n");
}
#endif



void compareOtherCorrelation (int arrayLen, int flag_)	{

	float db_sample [NUM_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
			{ //right
				{0.0294 ,0.0424 ,0.0824 ,0.1944 ,0.3684 ,0.4487 ,0.3406 ,0.0137 ,-0.3080 ,-0.4736 ,-0.4514 ,-0.2904 ,-0.0787 ,0.1341 ,0.2938 ,0.3142 ,0.2693 ,0.1737 },
				{-0.0102 ,-0.0143 ,-0.0182 ,-0.0350 ,0.0109 ,0.0332 ,-0.0101 ,-0.1582 ,-0.2743 ,-0.2864 ,-0.1941 ,-0.1510 ,-0.1038 ,-0.1134 ,-0.0419 ,-0.0167 ,0.0122 ,-0.0149},
				{0.5415 ,0.5232 ,0.5276 ,0.5076 ,0.5611 ,0.6911 ,0.7003 ,0.6202 ,0.4863 ,0.5229 ,0.5816 ,0.5577 ,0.4785 ,0.4868 ,0.5139 ,0.5559 ,0.5236 ,0.5170},
				{-0.0011 ,-0.0004 ,-0.0028 ,-0.0006 ,-0.0053 ,-0.0047 ,-0.0190 ,-0.0363 ,-0.0403 ,-0.0171 ,0.0126 ,0.0246 ,0.0103 ,-0.0011 ,-0.0146 ,-0.0072 ,-0.0038 ,0.0054},
				{0.0005 ,0.0006 ,0.0009 ,-0.0022 ,-0.0078 ,-0.0269 ,-0.0528 ,-0.0509 ,-0.0290 ,0.0188 ,0.0263 ,0.0092 ,0.0085 ,0.0252 ,0.0561 ,0.0406 ,0.0162 ,-0.0102},
				{0.0022 ,0.0023 ,0.0022 ,0.0091 ,-0.0059 ,-0.0512 ,-0.1178 ,-0.1485 ,-0.1217 ,-0.0594 ,-0.0043 ,0.0301 ,0.0651 ,0.0944 ,0.1054 ,0.0862 ,0.0589 ,0.0346},

			},
			{ //left
				{0.0340 ,0.0369 ,-0.0331 ,-0.2630 ,-0.4771 ,-0.4155 ,-0.0738 ,0.3171 ,0.5003 ,0.5474 ,0.4843 ,0.3700 ,0.2244 ,0.0899 ,-0.0367 ,-0.1415 ,-0.1714 ,-0.1286 },
				{0.0030 ,0.0004 ,0.0255 ,0.0209 ,-0.1178 ,-0.2858 ,-0.3288 ,-0.2000 ,-0.0588 ,0.0396 ,0.0543 ,0.0419 ,-0.0547 ,-0.0579 ,-0.0589 ,-0.0354 ,-0.0518 ,-0.0313},
				{0.5447 ,0.5324 ,0.5331 ,0.5564 ,0.6240 ,0.6779 ,0.5487 ,0.4812 ,0.4368 ,0.5017 ,0.4597 ,0.4428 ,0.4542 ,0.5141 ,0.5608 ,0.6068 ,0.6359 ,0.6067 },
				{-0.0055 ,-0.0042 ,-0.0074 ,-0.0099 ,-0.0038 ,0.0019 ,-0.0011 ,0.0118 ,0.0176 ,0.0192 ,0.0033 ,-0.0024 ,0.0088 ,0.0041 ,-0.0053 ,-0.0245 ,-0.0226 ,-0.0148},
				{0.0007 ,0.0009 ,-0.0015 ,-0.0139 ,-0.0188 ,0.0099 ,0.0389 ,0.0130 ,-0.0100 ,-0.0161 ,0.0103 ,-0.0027 ,-0.0350 ,-0.0560 ,-0.0576 ,-0.0404 ,-0.0182 ,0.0048 },
				{0.0089 ,0.0049 ,-0.0001 ,-0.0047 ,0.0319 ,0.1076 ,0.1808 ,0.1924 ,0.1432 ,0.0776 ,0.0057 ,-0.0560 ,-0.0986 ,-0.1155 ,-0.1200 ,-0.1088 ,-0.0780 ,-0.0358 }

			},
			{ //front
				{0.0969 ,0.1261 ,0.0328 ,-0.0320 ,-0.0234 ,0.0704 ,0.0601 ,0.0402 ,0.0189 ,0.0143 ,-0.0068 ,-0.0139 ,-0.0186 ,-0.0169 ,-0.0188 ,-0.0185 ,-0.0168 ,-0.0149 },
				{0.0940 ,-0.1825 ,-0.4067 ,-0.4740 ,-0.4353 ,-0.3265 ,-0.1829 ,0.0766 ,0.3170 ,0.4392 ,0.3957 ,0.2728 ,0.1597 ,0.0837 ,0.0532 ,0.0331 ,0.0330 ,0.0390 },
				{0.0096 ,-0.0088 ,-0.0612 ,0.0496 ,0.0205 ,0.0845 ,-0.0242 ,-0.0481 ,-0.0354 ,0.0214 ,0.0533 ,0.0295 ,0.0133 ,-0.0156 ,-0.0056 ,0.0015 ,0.0100 ,0.0017 },
				{0.0401 ,0.0252 ,-0.0246 ,-0.0136 ,-0.0201 ,0.0075 ,-0.0170 ,-0.0338 ,-0.0525 ,-0.0533 ,-0.0239 ,-0.0033 ,0.0093 ,0.0033 ,-0.0018 ,-0.0018 ,0.0006 ,-0.0002},
				{0.0003 ,0.0399 ,0.0697 ,0.0313 ,-0.0005 ,-0.0351 ,-0.0149 ,-0.0194 ,-0.0058 ,0.0023 ,0.0123 ,0.0100 ,0.0061 ,0.0028 ,0.0003 ,-0.0022 ,0.0005 ,0.0015 },
				{-0.0444 ,-0.0733 ,-0.0714 ,-0.0137 ,0.0385 ,0.0809 ,0.0756 ,0.0711 ,0.0286 ,-0.0081 ,-0.0313 ,-0.0243 ,-0.0122 ,-0.0007 ,0.0036 ,0.0041 ,0.0034 ,0.0021 }
			/*
				{-0.0059 , -0.0077 , -0.0104 , -0.0268 , -0.0387 , -0.0077 , 0.0716 , 0.1727 , 0.1733 , 0.0085 , 0.0033 , 0.0030 , 0.1628 , 0.0768 , 0.0680 , -0.0214 , -0.0278 , -0.0536 , 0.0300 , 0.0051 },
				{0.1095 , 0.1110 , 0.1180 , 0.1582 , 0.3163 , 0.5360 , 0.6272 , 0.3118 , -0.2047 , -0.6817 , -0.6667 , -0.5693 , -0.3196 , -0.1261 , 0.2427 , 0.5221 , 0.5137 , 0.3184 , 0.0732 , 0.1630 },
				{0.1095 , 0.1110 , 0.1180 , 0.1582 , 0.3163 , 0.5360 , 0.6272 , 0.3118 , -0.2047 , -0.6817 , -0.6667 , -0.5693 , -0.3196 , -0.1261 , 0.2427 , 0.5221 , 0.5137 , 0.3184 , 0.0732 , 0.1630 },
				{-0.0036 , -0.0068 , -0.0080 , -0.0033 , 0.0390 , 0.0588 , -0.0025 , -0.0482 , -0.1019 , -0.0072 , 0.0139 , -0.0518 , -0.1265 , -0.1823 , -0.0283 , 0.0003 , 0.0196 , 0.0067 , -0.0240 , 0.0034},
				{-0.0012 , -0.0010 , -0.0019 , -0.0064 , -0.0068 , -0.0024 , 0.0133 , 0.0227 , -0.0404 , -0.0935 , -0.1073 , -0.0171 , 0.0384 , 0.0501 , 0.0236 , 0.0215 , 0.0141 , 0.0094 , -0.0047 , 0.0015 },
				{0.0002 , 0.0003 , 0.0009 , -0.0051 , -0.0394 , -0.0550 , -0.0844 , -0.0271 , 0.0288 , 0.0525 , 0.0357 , -0.0335 , -0.0082 , -0.0035 , 0.0495 , 0.0573 , 0.0344 , -0.0021 , 0.0001 , 0.0014}
*/
			},
			{// back
				{-0.0193 ,-0.0554 ,-0.0927 ,-0.1154 ,-0.0909 ,-0.0266 ,0.0347 ,0.0654 ,0.0647 ,0.0414 ,0.0121 ,0.0158 ,0.0295 ,0.0527 ,0.0534 ,0.0438 ,0.0343 ,0.0316 },
				{0.1203 ,0.2916 ,0.4127 ,0.3985 ,0.3370 ,0.2472 ,0.1262 ,-0.0246 ,-0.1566 ,-0.2351 ,-0.2290 ,-0.1673 ,-0.0867 ,-0.0265 ,0.0058 ,0.0273 ,0.0341 ,0.0345},
				{0.5738 ,0.6149 ,0.5962 ,0.5149 ,0.4913 ,0.4742 ,0.4719 ,0.4682 ,0.5143 ,0.5629 ,0.5830 ,0.5817 ,0.5402 ,0.5361 ,0.5353 ,0.5389 ,0.5264 ,0.5110 },
				{-0.0524 ,-0.0584 ,-0.0193 ,0.0274 ,0.0542 ,0.0547 ,0.0403 ,0.0217 ,-0.0026 ,-0.0152 ,-0.0199 ,-0.0134 ,-0.0060 ,0.0030 ,0.0033 ,0.0044 ,0.0033 ,0.0009},
				{0.0434 ,0.0811 ,0.0571 ,-0.0018 ,-0.0650 ,-0.0660 ,-0.0463 ,-0.0211 ,-0.0076 ,0.0026 ,-0.0005 ,0.0011 ,0.0002 ,-0.0020 ,-0.0001 ,0.0017 ,0.0012 ,-0.0006 },
				{0.0017 ,-0.0033 ,-0.0015 ,0.0136 ,0.0366 ,0.0331 ,0.0195 ,-0.0105 ,-0.0231 ,-0.0289 ,-0.0175 ,-0.0063 ,0.0054 ,0.0083 ,0.0067 ,0.0032 ,-0.0003 ,-0.0021 },

				/*{0.0574 , 0.0552 , -0.0143 , -0.1635 , -0.3004 , -0.3480 , -0.1605 , 0.0703 , 0.3481 , 0.4569 , 0.4859 , 0.3513 , 0.1581 , -0.1213 , -0.2503 , -0.2458 , -0.0965 , -0.0166 , 0.0148 , 0.0630 },
				{-0.0263 , -0.0230 , 0.0013 , 0.0181 , 0.0515 , 0.0985 , 0.1062 , 0.0831 , 0.0303 , 0.0093 , 0.0255 , 0.0346 , 0.0698 , 0.0381 , 0.0262 , 0.0296 , 0.0735 , 0.0821 , 0.0405 , 0.0014 },
				{0.4917 , 0.4958 , 0.4929 , 0.5011 , 0.5924 , 0.6176 , 0.6218 , 0.5713 , 0.5572 , 0.5099 , 0.4449 , 0.4435 , 0.5006 , 0.5084 , 0.5583 , 0.5915 , 0.5832 , 0.5248 , 0.5337 , 0.0028 },
				{-0.0014 , -0.0054 , -0.0046 , -0.0132 , -0.0228 , -0.0414 , -0.0470 , -0.0313 , 0.0017 , 0.0357 , 0.0389 , 0.0377 , 0.0360 , 0.0259 , 0.0056 , -0.0144 , -0.0162 , -0.0104 , -0.0015 , 0.0007 },
				{0.0061 , -0.0006 , -0.0023 , -0.0388 , -0.0669 , -0.0608 , -0.0110 , 0.0385 , 0.0646 , 0.0461 , 0.0112 , -0.0407 , -0.0398 , -0.0417 , -0.0444 , -0.0312 , 0.0048 , 0.0204 , -0.0104 , 0.0013 },
				{0.0001 , 0.0011 , -0.0036 , -0.0065 , 0.0102 , 0.0433 , 0.0644 , 0.0568 , 0.0287 , 0.0055 , -0.0086 , -0.0194 , -0.0286 , -0.0274 , -0.0184 , 0.0049 , 0.0135 , 0.0158 , 0.0073 , 0.0007}
			*/}

	};
	int16_t WMA_SENSOR_local [AXIS_NUM][WMA_SAMPLE_NUM];
	int nLoopLen = 0, nLoopStart = 0;
	float db_average [NUM_OF_DB][AXIS_NUM] = {
			{0.0613, -0.077, 0.5498, -0.0056, 0.0013, -0.001},	//right
			{0.048, -0.0609, 0.5399, 0.0019, -0.0107, 0.0075},	//left
			{0.0155 , -0.0006, 0.0053, -0.0089, 0.0055, 0.0016},	//front
			{0.0044, 0.0616, 0.5353, 0.0014, -0.0013, 0.0019}	//back
	};
	float db_cov [NUM_OF_DB][AXIS_NUM] = {
			{0.0795, 0.0097, 0.004, 0.0003, 0.0008, 0.0055},	//right
			{0.0937, 0.0119, 0.0050, 0.0001, 0.0006, 0.0099},	//left
			{0.0021, 0.0783, 0.0013, 0.0006, 0.0005, 0.0020},	//front
			{0.0033, 0.0425, 0.0019, 0.0010, 0.0013, 0.0003}	//back
	};
	float average [AXIS_NUM] = {0,0,0,0,0,0};
	int nLoop, nLoop2, nLoop3;
	float cov [NUM_OF_DB][AXIS_NUM];
	float cov_self [AXIS_NUM] = {0,0,0,0,0,0};
	float corr [NUM_OF_DB][AXIS_NUM];
	float corr_int_local [NUM_OF_DB][AXIS_NUM];

	memset (cov, '\0', sizeof(cov));
	memset (corr, '\0', sizeof(corr));
	memset (corr_int_local, '\0', sizeof (corr_int_local));


	memset (WMA_SENSOR_local, '\0', sizeof(WMA_SENSOR_local));
	if (flag_ < 1)	{
		nLoopLen = arrayLen;
		nLoopStart = 0;
		memcpy (WMA_SENSOR_local, WMA_temp, sizeof(WMA_SENSOR_local));
	}
	else	{
		nLoopLen = WMA_SAMPLE_NUM;
		nLoopStart = flag_;
		memcpy (WMA_SENSOR_local, WMA_SENSOR, sizeof(WMA_SENSOR_local));

	}

// ----------- initialization to here ---------


	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{	//average of incoming sensor value
		for (nLoop2 = 0; nLoop2 < nLoopLen ; nLoop2 ++)	{
			average [nLoop] += WMA_SENSOR_local [nLoop][nLoop2];
		} //for nLoop2

		average [nLoop] /= nLoopLen;

	} //for nLoop

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		float temp_float=0;
		for (nLoop2 = nLoopStart; nLoop2 < nLoopLen; nLoop2 ++)	{ //covariance //분자계산
			temp_float = WMA_SENSOR_local [nLoop][nLoop2 - nLoopStart] - average [nLoop];

			for (nLoop3 = 0; nLoop3 < NUM_OF_DB; nLoop3 ++)
				cov [nLoop3][nLoop] += (temp_float * (db_sample [nLoop3][nLoop][nLoop2] - db_average [nLoop3][nLoop]));

			cov_self [nLoop] += (temp_float * temp_float);

		} //for nLoop2

		for (nLoop3 = 0; nLoop3 < NUM_OF_DB; nLoop3 ++)
			cov [nLoop3][nLoop] /= (nLoopLen - nLoopStart);

		cov_self [nLoop] /= (nLoopLen - nLoopStart);
	} // for nLoop

	int tempSUM [NUM_OF_DB]= {0, 0, 0, 0};
	char tempArray [4] = {'R', 'L', 'F', 'B'};
	printf ("----------------\ncorrelation(len: %d, flag: %d\n", arrayLen, flag_);
	for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{	//correlation. //분모 계산

		printf ("(%c db)\t", tempArray [nLoop]);
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			if (cov_self [nLoop2] * db_cov [nLoop][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov_self [nLoop2] * db_cov [nLoop][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;
			corr_int_local [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *100);

			printf ("%d(%d) ", (int)corr_int_local [nLoop][nLoop2], ((int)(corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2]) / 100));
			tempSUM [nLoop] += ((int)(corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2]) / 100);
		} //for nLoop2
		printf (" --> %d \n", tempSUM [nLoop]);

	} //for nLoop
	printf ("\n");


//------------------------------------------------ deviation --------------
	/*int16_t gap_mean [NUM_OF_DB][AXIS_NUM];
	int16_t gap_deviation [NUM_OF_DB][AXIS_NUM];
	memset (gap_mean, 0x0, sizeof(gap_mean));
	memset (gap_deviation, 0x0, sizeof(gap_deviation));


	printf ("GAP dev!\n");
	int tempSUM_dev [NUM_OF_DB]= {0, 0, 0, 0};

	for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++){
			for (nLoop3 = nLoopStart; nLoop3 < nLoopLen; nLoop3 ++){
				gap_mean [nLoop][nLoop2] += abs( (db_sample [nLoop][nLoop2][nLoop3] * 1000) - WMA_SENSOR_local[nLoop2][nLoop3]);
			}
			gap_mean [nLoop][nLoop2] /= nLoopLen;
			printf ("(%d) ",gap_mean [nLoop][nLoop2]);
			for (nLoop3 = nLoopStart; nLoop3 < nLoopLen; nLoop3 ++){
				gap_deviation [nLoop][nLoop2] += abs( (db_sample [nLoop][nLoop2][nLoop3] * 1000) - WMA_SENSOR_local[nLoop2][nLoop3] - gap_mean [nLoop][nLoop2]);

			}
			gap_deviation [nLoop][nLoop2] /= nLoopLen;
			printf ("%d ", gap_deviation [nLoop][nLoop2]);
			tempSUM_dev [nLoop] +=  gap_deviation [nLoop][nLoop2];
		}
		printf (" ==) %d", tempSUM_dev [nLoop]);

		printf ("\n");

	}
	printf ("\n");

	printf ("result is ");
	for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{
		if (tempSUM [nLoop] > 0)
			printf ("%d, ", (int)((tempSUM [nLoop] * 100) / tempSUM_dev [nLoop]));
		else
			printf ("0, ");
	}
	printf ("\n");
*/



}


void normalizingFunction (int16_t sensor [AXIS_NUM][SAMPLE_NUM]){
	int nLoop, nLoop2;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			SENSOR [nLoop][nLoop2] = (int)(((float)sensor [nLoop][nLoop2] / NORMALIZATION_FACTOR) * 1000);
		}
	}

}




void crossCorrelation ()	{

	int nLoop, nLoop2;
	memset (WMA_temp, '\0', sizeof(WMA_SAMPLE_NUM));

	for (nLoop = -CROSS_FACTOR; nLoop < 1; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM + nLoop ; nLoop2 ++)	{
			WMA_temp [0][nLoop2] = WMA_SENSOR [0][-nLoop+ nLoop2];
			WMA_temp [1][nLoop2] = WMA_SENSOR [1][-nLoop+ nLoop2];
			WMA_temp [2][nLoop2] = WMA_SENSOR [2][-nLoop+ nLoop2];
			WMA_temp [3][nLoop2] = WMA_SENSOR [3][-nLoop+ nLoop2];
			WMA_temp [4][nLoop2] = WMA_SENSOR [4][-nLoop+ nLoop2];
			WMA_temp [5][nLoop2] = WMA_SENSOR [5][-nLoop+ nLoop2];
			//printf ("[1](%d:%d/%d:%d)  ",-nLoop+ nLoop2,WMA_SENSOR [0][-nLoop+ nLoop2], nLoop2, WMA_temp [0][nLoop2]);
			//printf ("(%d/%d)  ",WMA_SENSOR [0][-nLoop+ nLoop2], WMA_temp [0][nLoop2]);

		}
		//printf ("\n");
		compareOtherCorrelation (WMA_SAMPLE_NUM + nLoop, nLoop);
	}
	for (nLoop = 1; nLoop < CROSS_FACTOR; nLoop ++)	{
		compareOtherCorrelation (WMA_SAMPLE_NUM, nLoop);
	}
}



unsigned char gestureRecognition (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{


	int min_ [AXIS_NUM] = {10000,10000,30000,10000,10000,10000};
	int max_ [AXIS_NUM] = {-10000, -10000,-1000,-1000,-1000,-1000};

	int gaps [AXIS_NUM] = {0,0,0,0,0,0};
	int maxFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	int minFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	int Motionflag_ = 0;
	int nLoop, nLoop2;
	int result_ = 0 ;


	memset (WEIGHTED_AXIS, 2, sizeof (WEIGHTED_AXIS));
	normalizingFunction (sensor);



#ifdef WMA_FACTOR
	weightedMovingAverage (sensor);
#endif

	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{

		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{

			if (min_[nLoop] > SENSOR [nLoop][nLoop2])	{
				min_[nLoop] = SENSOR [nLoop][nLoop2];
				minFlag [nLoop] |= 0x1;
			} else if (max_[nLoop] < SENSOR [nLoop][nLoop2])	{
				max_[nLoop] = SENSOR [nLoop][nLoop2];
				maxFlag [nLoop] |= 0x1;
			}
			minFlag[nLoop] = minFlag[nLoop] << 1;
			maxFlag[nLoop] = maxFlag[nLoop] << 1;

		}

		gaps [nLoop] = max_ [nLoop] - min_ [nLoop];
		if (gaps [nLoop] > 900)	{
			Motionflag_ |= 0x1;
		}
		Motionflag_ = Motionflag_ << 1;

	} //for


	//	printf ("<INPUT>\n");
		for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
			for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM; nLoop2 ++)	{
				printf ("%d\t", WMA_SENSOR [nLoop][nLoop2] );
				//printf ("%d\t", sensor [nLoop][nLoop2] );
			}
			printf ("\n");

		}


	//printf ("flag: %d\n", flag_);

	if (!Motionflag_ )
		result_ = NONE;
	else if (Motionflag_ == 32)	{
		result_ = FRONT;
		WEIGHTED_AXIS [1] = 90;
	}
	else if (Motionflag_ == 64)	{
		result_ = SIDE;
		WEIGHTED_AXIS [0] = 90;
	}
	else if (Motionflag_ == 16)	{
		WEIGHTED_AXIS [2] = 90;
		result_ = UP;
	}
	else	{
		deriveCorrelation ();
		result_ = compareSelfCorrleation (CLOCK);
	}

	printf ("WEIGHTED: <");
	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{
		printf ("%d,", WEIGHTED_AXIS [nLoop]);
	}
	printf (">\n\n");

	crossCorrelation ();



	return result_;

}




/////////////////////////////////////////////////////////////////////////////////////////////
/////////////// 2017.01.02 //////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

#include "em_device.h"
#include "em_chip.h"
#include "em_usart.h"
#include "em_cmu.h"
#include "em_gpio.h"
#include "em_i2c.h"
#include "swCfg.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define WMA_FACTOR	3
//#undef WMA_FACTOR
#define WEIGHT	0.8
#undef WEIGHT
#define NORMALIZATION_FACTOR INT16_MAX

int16_t SENSOR [AXIS_NUM][SAMPLE_NUM];
#ifdef WMA_FACTOR
	#define WMA_SAMPLE_NUM	SAMPLE_NUM - WMA_FACTOR + 1
	int16_t WMA_SENSOR [AXIS_NUM][WMA_SAMPLE_NUM];
	int16_t WMA_temp [AXIS_NUM][WMA_SAMPLE_NUM];

#endif
#define CROSS_FACTOR	5
int8_t WEIGHTED_AXIS [6];
#define NUM_OF_DB	8

enum sensors_	{
	ACC_X,
	ACC_Y,
	ACC_Z,
	GY_X,
	GY_Y,
	GY_Z
};
int biggestValue [NUM_OF_DB];

int corr_int [AXIS_NUM][AXIS_NUM];



///////////////////////////////////////////////////////////////////////
void deriveCorrelation ()	{
///////////////////////////////////////////////////////////////////////
// A factor: The array of sensor data
// Return: NULL
//////////////////////////////////////////////////////////////////////

	float cov [AXIS_NUM][AXIS_NUM];
	float corr [AXIS_NUM][AXIS_NUM];
	float average [] = {0,0,0,0,0,0};
	int nLoop, nLoop2, nLoop3;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			average [nLoop] += SENSOR [nLoop][nLoop2];
		} //for nLoop2
		average [nLoop] /= SAMPLE_NUM;
	} //for nLoop



	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			cov [nLoop][nLoop2] = corr [nLoop][nLoop2] = corr_int[nLoop][nLoop2] = 0;
			for (nLoop3 = 0; nLoop3 < SAMPLE_NUM; nLoop3 ++)	{
				cov [nLoop][nLoop2] += (SENSOR [nLoop][nLoop3] - average [nLoop]) * (SENSOR [nLoop2][nLoop3] - average [nLoop2]);
			} // for nLoop3
			cov [nLoop][nLoop2] /= SAMPLE_NUM;

		} // for nLoop2
	} //for nLoop


	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = nLoop+1; nLoop2 < AXIS_NUM; nLoop2 ++)	{

			if (cov [nLoop][nLoop] * cov [nLoop2][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov [nLoop][nLoop] * cov [nLoop2][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;

			if ((corr [nLoop][nLoop2] < 0.5) && (corr [nLoop][nLoop2] > -0.5))	{	//filtering
				corr [nLoop][nLoop2] = 0;
			} //if
			else	{
				corr_int [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *100);
			}
		} //for nLoop2
	} //for nLoop

/*
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			printf ("%d\t", corr_int [nLoop][nLoop2] );
		}
		printf ("\n");
	}
	printf ("\n");
*/
} //function calculatCorrelation

//////////////////////////////////////////////////////////////////////
int compareSelfCorrleation (int db_id)	{
///////////////////////////////////////////////////////////////////////
// A factor: A DB id among 2, 3, 4, 5, 6, 7, 8, 9, 14, 15
// Return: detected DB id
//////////////////////////////////////////////////////////////////////

	int avg_gap [2] = {0,0};
	int result_ = 0;
	int nLoop, nLoop2, nLoop3;
	int filter_count = 0;
	float MIN = 10000.0;


	int total_db_count [2] = {22, 27};

	int db_corr [2][AXIS_NUM][AXIS_NUM] = {
			{		//for sensor1, CLOCK
					{0, 61, 00, 91, 69, 00 },
					{00, 00, 04, 59, 75, 00 },
					{00, 00, 00, 68, 25, 00 },
					{00, 00, 00, 00, 78, 00 },
					{00, 00, 00, 00, 00, 00 },
					{00, 00, 00, 00, 00, 00 },
				},

				{		//for sensor1, ANTI-CLOCK
					{00, 81, 59, -91, -83, -67 },
					{00, 00, -31, -81, -81, -91 },
					{00, 00, 00, -07, 55, -96 },
					{00, 00, 00, 00, 86, 98 },
					{00, 00, 00, 00, 00, 72 },
					{00, 00, 00, 00, 00, 00 },
				}
		};
	int db_count [2][AXIS_NUM][AXIS_NUM]= {
			{		//for sensor1, CLOCK
				{0, 3, 0, 21, 13, 0 },
				{0, 0, 4, 14, 16, 0 },
				{0, 0, 0, 6, 8, 0 } ,
				{0, 0, 0, 0, 16, 0 },
				{0, 0, 0, 0, 0, 0 },
				{0, 0, 0, 0, 0, 0 },
			},

			{		//for sensor1, ANTI-CLOCK
				{0, 18, 5, 24, 27, 1 },
				{0, 0, 12, 20, 25, 1 },
				{0, 0, 0, 4, 10, 1 },
				{0, 0, 0, 0, 27, 1 },
				{0, 0, 0, 0, 0, 1 },
				{0, 0, 0, 0, 0, 0 },
			},

	};

	for (nLoop = 0; nLoop < 2; nLoop ++)	{

		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			for (nLoop3 = nLoop2 + 1; nLoop3 < AXIS_NUM; nLoop3 ++)	{

				if ((db_count [nLoop][nLoop2][nLoop3] * 5) >  total_db_count [nLoop])	{
					avg_gap [nLoop] += abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]);
					filter_count ++;
					//printf ("%d\t", abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]));
				}


			} //for nLoop3
		} //for nLoop2

		if (filter_count == 0)
			filter_count ++;


		avg_gap [nLoop] /= filter_count;

		filter_count = 0;

		if ((avg_gap [nLoop] != 0) && (MIN > avg_gap [nLoop]))	{
			MIN = avg_gap [nLoop];
		}

	} //for nLoop


	if (avg_gap [0] < avg_gap [1])	{
		result_ = (db_id % 2 == 1) ? (db_id - 1) : (db_id);		//CLOCK
	}
	else	{
		result_ = (db_id % 2 == 1) ? (db_id) : (db_id + 1);		//ANTI-CLOCK
	}

	//printf ("<%d vs. %d> corr result is %d \n",  avg_gap[0],avg_gap[1], result_);

	return result_;
}


#ifdef WMA_FACTOR
void weightedMovingAverage (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{
	int nLoop, nLoop2, nLoop3;
	int16_t temp_avr;

	memset (WMA_SENSOR, '\0', sizeof(WMA_SENSOR));

	//printf ("<< WMA\n");
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < (SAMPLE_NUM - WMA_FACTOR + 1); nLoop2 ++)	{
			temp_avr = 0;
#ifndef WEIGHT
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR; nLoop3 ++)	{
				temp_avr +=  SENSOR [nLoop][nLoop2 + nLoop3];
			}
			WMA_SENSOR [nLoop][nLoop2] = temp_avr / WMA_FACTOR;

#else
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR-1; nLoop3 ++)	{
				temp_avr +=  SENSOR [nLoop][nLoop2 + nLoop3];
			}
			temp_avr *= (1-WEIGHT);
			temp_avr += (WEIGHT * SENSOR [nLoop][nLoop2 + nLoop3]);
			WMA_SENSOR [nLoop][nLoop2] = temp_avr;
#endif
			//printf ("(%d)%d  ", nLoop2, WMA_SENSOR [nLoop][nLoop2]);
		}
		//printf ("\n");
	}
	//printf ("\n");
}
#endif



void compareOtherCorrelation (int arrayLen, int flag_)	{

	float db_sample [NUM_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
			{ //right
				{0.0294 ,0.0424 ,0.0824 ,0.1944 ,0.3684 ,0.4487 ,0.3406 ,0.0137 ,-0.3080 ,-0.4736 ,-0.4514 ,-0.2904 ,-0.0787 ,0.1341 ,0.2938 ,0.3142 ,0.2693 ,0.1737 },
				{-0.0102 ,-0.0143 ,-0.0182 ,-0.0350 ,0.0109 ,0.0332 ,-0.0101 ,-0.1582 ,-0.2743 ,-0.2864 ,-0.1941 ,-0.1510 ,-0.1038 ,-0.1134 ,-0.0419 ,-0.0167 ,0.0122 ,-0.0149},
				{0.5415 ,0.5232 ,0.5276 ,0.5076 ,0.5611 ,0.6911 ,0.7003 ,0.6202 ,0.4863 ,0.5229 ,0.5816 ,0.5577 ,0.4785 ,0.4868 ,0.5139 ,0.5559 ,0.5236 ,0.5170},
				{-0.0011 ,-0.0004 ,-0.0028 ,-0.0006 ,-0.0053 ,-0.0047 ,-0.0190 ,-0.0363 ,-0.0403 ,-0.0171 ,0.0126 ,0.0246 ,0.0103 ,-0.0011 ,-0.0146 ,-0.0072 ,-0.0038 ,0.0054},
				{0.0005 ,0.0006 ,0.0009 ,-0.0022 ,-0.0078 ,-0.0269 ,-0.0528 ,-0.0509 ,-0.0290 ,0.0188 ,0.0263 ,0.0092 ,0.0085 ,0.0252 ,0.0561 ,0.0406 ,0.0162 ,-0.0102},
				{0.0022 ,0.0023 ,0.0022 ,0.0091 ,-0.0059 ,-0.0512 ,-0.1178 ,-0.1485 ,-0.1217 ,-0.0594 ,-0.0043 ,0.0301 ,0.0651 ,0.0944 ,0.1054 ,0.0862 ,0.0589 ,0.0346},

			},
			{ //left
				{0.0340 ,0.0369 ,-0.0331 ,-0.2630 ,-0.4771 ,-0.4155 ,-0.0738 ,0.3171 ,0.5003 ,0.5474 ,0.4843 ,0.3700 ,0.2244 ,0.0899 ,-0.0367 ,-0.1415 ,-0.1714 ,-0.1286 },
				{0.0030 ,0.0004 ,0.0255 ,0.0209 ,-0.1178 ,-0.2858 ,-0.3288 ,-0.2000 ,-0.0588 ,0.0396 ,0.0543 ,0.0419 ,-0.0547 ,-0.0579 ,-0.0589 ,-0.0354 ,-0.0518 ,-0.0313},
				{0.5447 ,0.5324 ,0.5331 ,0.5564 ,0.6240 ,0.6779 ,0.5487 ,0.4812 ,0.4368 ,0.5017 ,0.4597 ,0.4428 ,0.4542 ,0.5141 ,0.5608 ,0.6068 ,0.6359 ,0.6067 },
				{-0.0055 ,-0.0042 ,-0.0074 ,-0.0099 ,-0.0038 ,0.0019 ,-0.0011 ,0.0118 ,0.0176 ,0.0192 ,0.0033 ,-0.0024 ,0.0088 ,0.0041 ,-0.0053 ,-0.0245 ,-0.0226 ,-0.0148},
				{0.0007 ,0.0009 ,-0.0015 ,-0.0139 ,-0.0188 ,0.0099 ,0.0389 ,0.0130 ,-0.0100 ,-0.0161 ,0.0103 ,-0.0027 ,-0.0350 ,-0.0560 ,-0.0576 ,-0.0404 ,-0.0182 ,0.0048 },
				{0.0089 ,0.0049 ,-0.0001 ,-0.0047 ,0.0319 ,0.1076 ,0.1808 ,0.1924 ,0.1432 ,0.0776 ,0.0057 ,-0.0560 ,-0.0986 ,-0.1155 ,-0.1200 ,-0.1088 ,-0.0780 ,-0.0358 }

			},
			{ //front
/*				{0.0969 ,0.1261 ,0.0328 ,-0.0320 ,-0.0234 ,0.0704 ,0.0601 ,0.0402 ,0.0189 ,0.0143 ,-0.0068 ,-0.0139 ,-0.0186 ,-0.0169 ,-0.0188 ,-0.0185 ,-0.0168 ,-0.0149 },
				{0.0940 ,-0.1825 ,-0.4067 ,-0.4740 ,-0.4353 ,-0.3265 ,-0.1829 ,0.0766 ,0.3170 ,0.4392 ,0.3957 ,0.2728 ,0.1597 ,0.0837 ,0.0532 ,0.0331 ,0.0330 ,0.0390 },
				{0.0096 ,-0.0088 ,-0.0612 ,0.0496 ,0.0205 ,0.0845 ,-0.0242 ,-0.0481 ,-0.0354 ,0.0214 ,0.0533 ,0.0295 ,0.0133 ,-0.0156 ,-0.0056 ,0.0015 ,0.0100 ,0.0017 },
				{0.0401 ,0.0252 ,-0.0246 ,-0.0136 ,-0.0201 ,0.0075 ,-0.0170 ,-0.0338 ,-0.0525 ,-0.0533 ,-0.0239 ,-0.0033 ,0.0093 ,0.0033 ,-0.0018 ,-0.0018 ,0.0006 ,-0.0002},
				{0.0003 ,0.0399 ,0.0697 ,0.0313 ,-0.0005 ,-0.0351 ,-0.0149 ,-0.0194 ,-0.0058 ,0.0023 ,0.0123 ,0.0100 ,0.0061 ,0.0028 ,0.0003 ,-0.0022 ,0.0005 ,0.0015 },
				{-0.0444 ,-0.0733 ,-0.0714 ,-0.0137 ,0.0385 ,0.0809 ,0.0756 ,0.0711 ,0.0286 ,-0.0081 ,-0.0313 ,-0.0243 ,-0.0122 ,-0.0007 ,0.0036 ,0.0041 ,0.0034 ,0.0021 }
	*/
				{-0.0059 , -0.0077 , -0.0104 , -0.0268 , -0.0387 , -0.0077 , 0.0716 , 0.1727 , 0.1733 , 0.0085 , 0.0033 , 0.0030 , 0.1628 , 0.0768 , 0.0680 , -0.0214 , -0.0278 , -0.0536 , 0.0300 , 0.0051 },
				{0.1095 , 0.1110 , 0.1180 , 0.1582 , 0.3163 , 0.5360 , 0.6272 , 0.3118 , -0.2047 , -0.6817 , -0.6667 , -0.5693 , -0.3196 , -0.1261 , 0.2427 , 0.5221 , 0.5137 , 0.3184 , 0.0732 , 0.1630 },
				{0.1095 , 0.1110 , 0.1180 , 0.1582 , 0.3163 , 0.5360 , 0.6272 , 0.3118 , -0.2047 , -0.6817 , -0.6667 , -0.5693 , -0.3196 , -0.1261 , 0.2427 , 0.5221 , 0.5137 , 0.3184 , 0.0732 , 0.1630 },
				{-0.0036 , -0.0068 , -0.0080 , -0.0033 , 0.0390 , 0.0588 , -0.0025 , -0.0482 , -0.1019 , -0.0072 , 0.0139 , -0.0518 , -0.1265 , -0.1823 , -0.0283 , 0.0003 , 0.0196 , 0.0067 , -0.0240 , 0.0034},
				{-0.0012 , -0.0010 , -0.0019 , -0.0064 , -0.0068 , -0.0024 , 0.0133 , 0.0227 , -0.0404 , -0.0935 , -0.1073 , -0.0171 , 0.0384 , 0.0501 , 0.0236 , 0.0215 , 0.0141 , 0.0094 , -0.0047 , 0.0015 },
				{0.0002 , 0.0003 , 0.0009 , -0.0051 , -0.0394 , -0.0550 , -0.0844 , -0.0271 , 0.0288 , 0.0525 , 0.0357 , -0.0335 , -0.0082 , -0.0035 , 0.0495 , 0.0573 , 0.0344 , -0.0021 , 0.0001 , 0.0014}

			},
			{// back
	/*			{-0.0193 ,-0.0554 ,-0.0927 ,-0.1154 ,-0.0909 ,-0.0266 ,0.0347 ,0.0654 ,0.0647 ,0.0414 ,0.0121 ,0.0158 ,0.0295 ,0.0527 ,0.0534 ,0.0438 ,0.0343 ,0.0316 },
				{0.1203 ,0.2916 ,0.4127 ,0.3985 ,0.3370 ,0.2472 ,0.1262 ,-0.0246 ,-0.1566 ,-0.2351 ,-0.2290 ,-0.1673 ,-0.0867 ,-0.0265 ,0.0058 ,0.0273 ,0.0341 ,0.0345},
				{0.5738 ,0.6149 ,0.5962 ,0.5149 ,0.4913 ,0.4742 ,0.4719 ,0.4682 ,0.5143 ,0.5629 ,0.5830 ,0.5817 ,0.5402 ,0.5361 ,0.5353 ,0.5389 ,0.5264 ,0.5110 },
				{-0.0524 ,-0.0584 ,-0.0193 ,0.0274 ,0.0542 ,0.0547 ,0.0403 ,0.0217 ,-0.0026 ,-0.0152 ,-0.0199 ,-0.0134 ,-0.0060 ,0.0030 ,0.0033 ,0.0044 ,0.0033 ,0.0009},
				{0.0434 ,0.0811 ,0.0571 ,-0.0018 ,-0.0650 ,-0.0660 ,-0.0463 ,-0.0211 ,-0.0076 ,0.0026 ,-0.0005 ,0.0011 ,0.0002 ,-0.0020 ,-0.0001 ,0.0017 ,0.0012 ,-0.0006 },
				{0.0017 ,-0.0033 ,-0.0015 ,0.0136 ,0.0366 ,0.0331 ,0.0195 ,-0.0105 ,-0.0231 ,-0.0289 ,-0.0175 ,-0.0063 ,0.0054 ,0.0083 ,0.0067 ,0.0032 ,-0.0003 ,-0.0021 },
*/
				{0.0574 , 0.0552 , -0.0143 , -0.1635 , -0.3004 , -0.3480 , -0.1605 , 0.0703 , 0.3481 , 0.4569 , 0.4859 , 0.3513 , 0.1581 , -0.1213 , -0.2503 , -0.2458 , -0.0965 , -0.0166 , 0.0148 , 0.0630 },
				{-0.0263 , -0.0230 , 0.0013 , 0.0181 , 0.0515 , 0.0985 , 0.1062 , 0.0831 , 0.0303 , 0.0093 , 0.0255 , 0.0346 , 0.0698 , 0.0381 , 0.0262 , 0.0296 , 0.0735 , 0.0821 , 0.0405 , 0.0014 },
				{0.4917 , 0.4958 , 0.4929 , 0.5011 , 0.5924 , 0.6176 , 0.6218 , 0.5713 , 0.5572 , 0.5099 , 0.4449 , 0.4435 , 0.5006 , 0.5084 , 0.5583 , 0.5915 , 0.5832 , 0.5248 , 0.5337 , 0.0028 },
				{-0.0014 , -0.0054 , -0.0046 , -0.0132 , -0.0228 , -0.0414 , -0.0470 , -0.0313 , 0.0017 , 0.0357 , 0.0389 , 0.0377 , 0.0360 , 0.0259 , 0.0056 , -0.0144 , -0.0162 , -0.0104 , -0.0015 , 0.0007 },
				{0.0061 , -0.0006 , -0.0023 , -0.0388 , -0.0669 , -0.0608 , -0.0110 , 0.0385 , 0.0646 , 0.0461 , 0.0112 , -0.0407 , -0.0398 , -0.0417 , -0.0444 , -0.0312 , 0.0048 , 0.0204 , -0.0104 , 0.0013 },
				{0.0001 , 0.0011 , -0.0036 , -0.0065 , 0.0102 , 0.0433 , 0.0644 , 0.0568 , 0.0287 , 0.0055 , -0.0086 , -0.0194 , -0.0286 , -0.0274 , -0.0184 , 0.0049 , 0.0135 , 0.0158 , 0.0073 , 0.0007}
			},
			{ //CLOCK
				{0.0955 , 0.2635 , 0.3904 , 0.4570 , 0.4397 , 0.2961 , 0.0711 , -0.2096 , -0.4202 , -0.5015 , -0.3693 , -0.1749 , 0.0070 , 0.0755 , 0.0992 , 0.0825 , 0.0641 , 0.0245 },
				{-0.0409 , -0.0365 , -0.0492 , -0.0303 , -0.0183 , -0.0530 , -0.0996 , -0.1998 , -0.2290 , -0.2101 , -0.1068 , -0.0007 , 0.0223 , 0.0035 , -0.0563 , -0.0780 , -0.0772 , -0.0604 },
				{0.9343 , 0.8526 , 0.6681 , 0.3260 , 0.1101 , -0.0960 , -0.1095 , -0.0322 , 0.2818 , 0.5574 , 0.7934 , 0.8148 , 0.8499 , 0.7628 , 0.7038 , 0.6051 , 0.5729 , 0.5071 },
				{0.0949 , 0.1808 , 0.2183 , 0.1990 , 0.1479 , 0.0787 , -0.0041 , -0.0802 , -0.1401 , -0.1749 , -0.1750 , -0.1497 , -0.1059 , -0.0689 , -0.0285 , -0.0084 , 0.0057 , 0.0033 },
				{-0.0535 , -0.0383 , 0.0024 , 0.0002 , -0.0190 , -0.0616 , -0.0948 , -0.1254 , -0.1309 , -0.0935 , -0.0330 , 0.0154 , 0.0333 , 0.0384 , 0.0279 , 0.0194 , 0.0102 , 0.0106 },
				{0.1447 , 0.0909 , 0.0195 , -0.0454 , -0.1270 , -0.1813 , -0.2095 , -0.1864 , -0.1162 , -0.0189 , 0.0760 , 0.1204 , 0.1333 , 0.1138 , 0.0885 , 0.0553 , 0.0289 , 0.0085 }

			},
			{ //ANTI-CLOCK
				{0.1536 , -0.2041 , -0.3660 , -0.3371 , -0.2394 , -0.1310 , -0.0166 , 0.0971 , 0.1728 , 0.2668 , 0.3068 , 0.2842 , 0.1848 , 0.0856 , 0.0062 , -0.0730 , -0.1335 , -0.1470 },
				{-0.1114 , -0.3936 , -0.4661 , -0.4337 , -0.2992 , -0.1715 , -0.0327 , 0.0819 , 0.1073 , 0.0832 , 0.0411 , 0.0020 , -0.0990 , -0.1627 , -0.1772 , -0.1342 , -0.1240 , -0.1206 },
				{0.8617 , 0.9261 , 0.8838 , 0.6318 , 0.3124 , 0.0442 , -0.0956 , -0.1198 , 0.0114 , 0.2855 , 0.5566 , 0.7435 , 0.7857 , 0.7948 , 0.7607 , 0.6815 , 0.5950 , 0.5346 },
				{0.0273 , 0.0842 , 0.1378 , 0.1700 , 0.1474 , 0.0836 , 0.0106 , -0.0626 , -0.1188 , -0.1643 , -0.1755 , -0.1649 , -0.1205 , -0.0654 , -0.0207 , 0.0017 , 0.0102 , 0.0143 },
				{0.0063 , 0.0011 , 0.0328 , 0.0913 , 0.1344 , 0.1259 , 0.1043 , 0.0681 , 0.0230 , -0.0114 , -0.0069 , 0.0084 , 0.0073 , -0.0097 , -0.0118 , 0.0063 , 0.0124 , 0.0131 },
				{-0.2334 , -0.2022 , -0.0971 , 0.0079 , 0.0877 , 0.1477 , 0.1952 , 0.1990 , 0.1613 , 0.1021 , 0.0317 , -0.0307 , -0.0822 , -0.1063 , -0.1069 , -0.0932 , -0.0673 , -0.0412 	}
			},
			{ //LOW CLOCK
				{0.3006 , 0.3424 , 0.3616 , 0.3218 , 0.2365 , 0.1268 , 0.0348 , -0.0595 , -0.1366 , -0.2006 , -0.2176 , -0.1927 , -0.1407 , -0.0507 , 0.0183 , 0.0903 , 0.0999 , 0.0949 },
				{0.1700 , 0.1202 , -0.0088 , -0.1808 , -0.2990 , -0.3368 , -0.2961 , -0.2510 , -0.1992 , -0.1522 , -0.0834 , -0.0190 , 0.0253 , 0.0719 , 0.0642 , 0.0596 , 0.0109 , -0.0116},
				{0.5936 , 0.5105 , 0.4762 , 0.4848 , 0.4739 , 0.4619 , 0.4485 , 0.4307 , 0.4674 , 0.5326 , 0.6218 , 0.6579 , 0.6215 , 0.5714 , 0.5328 , 0.5451 , 0.5481 , 0.5459},
				{0.0424 , 0.0388 , 0.0259 , 0.0277 , 0.0150 , 0.0089 , -0.0023 , -0.0146 , -0.0343 , -0.0444 , -0.0397 , -0.0220 , -0.0053 , 0.0012 , 0.0016 , 0.0028 , 0.0026 , 0.0015},
				{-0.0209 , -0.0085 , -0.0046 , 0.0032 , 0.0024 , -0.0102 , -0.0248 , -0.0350 , -0.0387 , -0.0340 , -0.0158 , 0.0087 , 0.0263 , 0.0258 , 0.0199 , 0.0114 , 0.0149 , 0.0144 },
				{0.0545 , -0.0140 , -0.0798 , -0.1114 , -0.1173 , -0.0899 , -0.0649 , -0.0461 , -0.0343 , -0.0190 , 0.0032 , 0.0261 , 0.0493 , 0.0662 , 0.0693 , 0.0661 , 0.0546 , 0.0458}
			},
			{ //LOW ANTI
				{0.1573 , 0.0709 , -0.0684 , -0.1793 , -0.2324 , -0.2304 , -0.1262 , 0.0454 , 0.2397 , 0.3674 , 0.4178 , 0.4139 , 0.3993 , 0.3387 , 0.2261 , 0.0797 , -0.0449 , -0.0944 },
				{0.1311 , 0.1593 , 0.0867 , -0.0606 , -0.2740 , -0.4536 , -0.5189 , -0.4771 , -0.3686 , -0.2549 , -0.1614 , -0.0310 , 0.0442 , 0.1334 , 0.1017 , 0.0703 , -0.0309 , -0.0758},
				{0.5781 , 0.6344 , 0.6500 , 0.7000 , 0.5991 , 0.5298 , 0.3672 , 0.3612 , 0.3605 , 0.3965 , 0.4605 , 0.5343 , 0.5890 , 0.6164 , 0.6203 , 0.6092 , 0.5857 , 0.5742 },
				{-0.0082 , -0.0014 , -0.0030 , 0.0220 , 0.0284 , 0.0448 , 0.0199 , 0.0129 , -0.0040 , -0.0155 , -0.0296 , -0.0421 , -0.0619 , -0.0673 , -0.0563 , -0.0247 , 0.0031 , 0.0179},
				{-0.0161 , -0.0257 , -0.0311 , -0.0139 , 0.0320 , 0.0536 , 0.0532 , 0.0122 , -0.0107 , -0.0320 , -0.0445 , -0.0323 , 0.0026 , 0.0309 , 0.0284 , 0.0062 , -0.0175 , -0.0177 },
				{-0.0617 , -0.1022 , -0.1290 , -0.1193 , -0.0908 , -0.0126 , 0.0854 , 0.1786 , 0.2294 , 0.2139 , 0.1750 , 0.1055 , 0.0399 , -0.0448 , -0.1064 , -0.1503 , -0.1464 , -0.1117 }
			}


	};
	int16_t WMA_SENSOR_local [AXIS_NUM][WMA_SAMPLE_NUM];
	int nLoopLen = 0, nLoopStart = 0;
	float db_average [NUM_OF_DB][AXIS_NUM] = {
			{0.0613, -0.077, 0.5498, -0.0056, 0.0013, -0.001},	//right
			{0.048, -0.0609, 0.5399, 0.0019, -0.0107, 0.0075},	//left
			//{0.0155 , -0.0006, 0.0053, -0.0089, 0.0055, 0.0016},	//front
			{0.03, 0.0732, 0.0732, -0.0240, -0.0047, 0.0001},
			//{0.0044, 0.0616, 0.5353, 0.0014, -0.0013, 0.0019}	//back
			{0.0148, 0.0405, 0.5337, -0.0015, -0.0104, 0.0073},
			{0.0384, -0.0733, 0.5057, -0.0004, -0.0273, -0.0003}, //clock
			{-0.0050, -0.1339, 0.5108, -0.0114, 0.0330, -0.0071}, //ANTI-clock
			{0.0572, -0.0731, 0.5291, 0.0003, -0.0036, -0.0079}, //LOW CLOCK
			{0.0989, -0.1100, 0.5426, -0.0092, -0.0012, -0.0026} //LOW ANTI

	};
	float db_cov [NUM_OF_DB][AXIS_NUM] = {
			{0.0795, 0.0097, 0.004, 0.0003, 0.0008, 0.0055},	//right
			{0.0937, 0.0119, 0.0050, 0.0001, 0.0006, 0.0099},	//left
			//{0.0021, 0.0783, 0.0013, 0.0006, 0.0005, 0.0020},	//front
			{0.0051, 0.1630, 0.1630, 0.0034, 0.0015, 0.0014},
			//{0.0033, 0.0425, 0.0019, 0.0010, 0.0013, 0.0003}	//back
			{0.063, 0.0014, 0.0028, 0.0007, 0.0013, 0.0007},
			{0.0759, 0.0050, 0.1121, 0.0158, 0.0028, 0.0131},	//CLOCK
			{0.0421, 0.0285, 0.1158, 0.0114, 0.0023, 0.0163},	//ANTI-CLOCK
			{0.0363, 0.0232, 0.0041, 0.0006, 0.0004, 0.0040},	//LOW CLOCK
			{0.0498, 0.0491, 0.0108, 0.0010, 0.0009, 0.0169}	//LOW ANTI

	};
	unsigned char weighted_flag_db [NUM_OF_DB][AXIS_NUM] =	{
			{1, 0, 0, 1, 0, 0}, //right
			{1, 0, 0, 1, 0, 0}, //left
			{0, 1, 0, 0, 1, 0}, //front
			{0, 1, 0, 0, 1, 0}, //back
			{1, 0, 1, 1, 1, 1}, //clock
			{1, 0, 1, 1, 1, 1}, //anti-clock
			{1, 1, 0, 1, 1, 1}, //clock
			{1, 1, 0, 1, 1, 1}, //anti-clock

	};

	float average [AXIS_NUM] = {0,0,0,0,0,0};
	int nLoop, nLoop2, nLoop3;
	float cov [NUM_OF_DB][AXIS_NUM];
	float cov_self [AXIS_NUM] = {0,0,0,0,0,0};
	float corr [NUM_OF_DB][AXIS_NUM];
	float corr_int_local [NUM_OF_DB][AXIS_NUM];

	memset (cov, '\0', sizeof(cov));
	memset (corr, '\0', sizeof(corr));
	memset (corr_int_local, '\0', sizeof (corr_int_local));


	memset (WMA_SENSOR_local, '\0', sizeof(WMA_SENSOR_local));
	if (flag_ < 1)	{
		nLoopLen = arrayLen;
		nLoopStart = 0;
		memcpy (WMA_SENSOR_local, WMA_temp, sizeof(WMA_SENSOR_local));
	}
	else	{
		nLoopLen = WMA_SAMPLE_NUM;
		nLoopStart = flag_;
		memcpy (WMA_SENSOR_local, WMA_SENSOR, sizeof(WMA_SENSOR_local));
	}

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{	//average of incoming sensor value
		for (nLoop2 = 0; nLoop2 < nLoopLen ; nLoop2 ++)	{
			average [nLoop] += WMA_SENSOR_local [nLoop][nLoop2];
		} //for nLoop2

		average [nLoop] /= nLoopLen;

	} //for nLoop

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		float temp_float=0;
		for (nLoop2 = nLoopStart; nLoop2 < nLoopLen; nLoop2 ++)	{ //covariance //분자계산
			temp_float = WMA_SENSOR_local [nLoop][nLoop2 - nLoopStart] - average [nLoop];

			for (nLoop3 = 0; nLoop3 < NUM_OF_DB; nLoop3 ++)
				cov [nLoop3][nLoop] += (temp_float * (db_sample [nLoop3][nLoop][nLoop2] - db_average [nLoop3][nLoop]));


			cov_self [nLoop] += (temp_float * temp_float);

		} //for nLoop2

		for (nLoop3 = 0; nLoop3 < NUM_OF_DB; nLoop3 ++)
			cov [nLoop3][nLoop] /= (nLoopLen - nLoopStart);

		cov_self [nLoop] /= (nLoopLen - nLoopStart);
	} // for nLoop

	int tempSUM [NUM_OF_DB]= {0, 0, 0, 0};
//	printf ("----------------\ncorrelation(len: %d, flag: %d\n", arrayLen, flag_);
	for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{	//correlation. //분모 계산

	//	char tempArray [4] = {'R', 'L', 'F', 'B'};
	//	printf ("(%c db)\t", tempArray[nLoop]);
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			if (cov_self [nLoop2] * db_cov [nLoop][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov_self [nLoop2] * db_cov [nLoop][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;

			corr_int_local [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *100) * weighted_flag_db [nLoop][nLoop2];

		//	printf ("%d(%d) ", (int)corr_int_local [nLoop][nLoop2], ((int)(corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2]) / 100));
			tempSUM [nLoop] += ((int)(corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2]) / 100) ;

		} //for nLoop2
		//printf (" --> %d \n", tempSUM[nLoop]);

	} //for nLoop
	//printf ("\n");

	//------------------------------------------------ deviation --------------
		int gap_mean [NUM_OF_DB][AXIS_NUM];
		int gap_deviation [NUM_OF_DB][AXIS_NUM];
		memset (gap_mean, 0x0, sizeof(gap_mean));
		memset (gap_deviation, 0x0, sizeof(gap_deviation));


	//	printf ("GAP dev!\n");
		int tempSUM_dev [NUM_OF_DB]= {0, 0, 0, 0};

		for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{
			for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++){
				for (nLoop3 = nLoopStart; nLoop3 < nLoopLen; nLoop3 ++){
					gap_mean [nLoop][nLoop2] += abs( (int)(db_sample [nLoop][nLoop2][nLoop3] * 1000) - (int) WMA_SENSOR_local[nLoop2][nLoop3]);
				}
			//	printf ("(%d",gap_mean [nLoop][nLoop2]);
				gap_mean [nLoop][nLoop2] /= nLoopLen;
			//	printf ("/%d) ",gap_mean [nLoop][nLoop2]);

				for (nLoop3 = nLoopStart; nLoop3 < nLoopLen; nLoop3 ++){
					gap_deviation [nLoop][nLoop2] += abs( (int)(db_sample [nLoop][nLoop2][nLoop3] * 1000) - (int)WMA_SENSOR_local[nLoop2][nLoop3] - (int)gap_mean [nLoop][nLoop2] );
				}

				gap_deviation [nLoop][nLoop2] /= nLoopLen;
			//	printf ("%d ", gap_deviation [nLoop][nLoop2]);
				tempSUM_dev [nLoop] +=  gap_deviation [nLoop][nLoop2];
			}
		//	printf (" ==) %d", tempSUM_dev [nLoop]);

		//	printf ("\n");
		}
	//	printf ("\n");

		int temp_int;
		printf ("result is ");
		for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{
			if (tempSUM [nLoop] > 0)	{
				temp_int = (int)((tempSUM [nLoop] * 100000) / tempSUM_dev [nLoop]);
				printf ("%d, ", temp_int);

			}
			else	{
				temp_int = 0;
				printf ("0, ");
			}

			if (biggestValue [nLoop] < temp_int)
				biggestValue [nLoop] = temp_int;
		}
		printf ("\n");

}


void normalizingFunction (int16_t sensor [AXIS_NUM][SAMPLE_NUM]){
	int nLoop, nLoop2;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			SENSOR [nLoop][nLoop2] = (int)(((float)sensor [nLoop][nLoop2] / NORMALIZATION_FACTOR) * 1000);
		}
	}

}




void crossCorrelation ()	{

	int nLoop, nLoop2, max_ = 0, db_num = 0;
	memset (WMA_temp, '\0', sizeof(WMA_SAMPLE_NUM));
	memset (biggestValue, 0, sizeof (biggestValue));

	for (nLoop = -CROSS_FACTOR; nLoop < 1; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM + nLoop ; nLoop2 ++)	{
			WMA_temp [0][nLoop2] = WMA_SENSOR [0][-nLoop+ nLoop2];
			WMA_temp [1][nLoop2] = WMA_SENSOR [1][-nLoop+ nLoop2];
			WMA_temp [2][nLoop2] = WMA_SENSOR [2][-nLoop+ nLoop2];
			WMA_temp [3][nLoop2] = WMA_SENSOR [3][-nLoop+ nLoop2];
			WMA_temp [4][nLoop2] = WMA_SENSOR [4][-nLoop+ nLoop2];
			WMA_temp [5][nLoop2] = WMA_SENSOR [5][-nLoop+ nLoop2];
			//printf ("[1](%d:%d/%d:%d)  ",-nLoop+ nLoop2,WMA_SENSOR [0][-nLoop+ nLoop2], nLoop2, WMA_temp [0][nLoop2]);
			//printf ("(%d/%d)  ",WMA_SENSOR [0][-nLoop+ nLoop2], WMA_temp [0][nLoop2]);

		}
		//printf ("\n");
		compareOtherCorrelation (WMA_SAMPLE_NUM + nLoop, nLoop);
	}
	for (nLoop = 1; nLoop < CROSS_FACTOR; nLoop ++)	{
		compareOtherCorrelation (WMA_SAMPLE_NUM, nLoop);
	}

	for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{
		printf ("%d ",  biggestValue [nLoop]);
		if (biggestValue [nLoop] > max_)	{
			max_ = biggestValue [nLoop];
			db_num = nLoop;
		}
	}

	printf ("<< max db is %d >>\n", db_num);

	switch (db_num){
	case 0:
		printf (" RIGHT\n"); break;
	case 1:
			printf (" LEFT\n"); break;
	case 2:
			printf (" FRONT\n"); break;
	case 3:
			printf (" BACK\n"); break;
	case 4:
			printf (" CLOCK\n"); break;
	case 5:
			printf (" ANTI-CLOCK\n"); break;
	case 6:
			printf (" LOW-CLOCK\n"); break;
	case 7:
			printf (" LOW-ANTI\n"); break;

	}


}



unsigned char gestureRecognition (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{


	int min_ [AXIS_NUM] = {10000,10000,30000,10000,10000,10000};
	int max_ [AXIS_NUM] = {-10000, -10000,-1000,-1000,-1000,-1000};

	int gaps [AXIS_NUM] = {0,0,0,0,0,0};
	int maxFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	int minFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	int Motionflag_ = 0;
	int nLoop, nLoop2;
	int result_ = 0 ;


	memset (WEIGHTED_AXIS, 2, sizeof (WEIGHTED_AXIS));
	normalizingFunction (sensor);


#ifdef WMA_FACTOR
	weightedMovingAverage (sensor);
#endif


	//	printf ("<INPUT>\n");
		for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
			for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM; nLoop2 ++)	{
				printf ("%d\t", WMA_SENSOR [nLoop][nLoop2] );
			}
			printf ("\n");
		}
		printf ("\n");



	char temp_flag = 0;
	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{

		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM; nLoop2 ++)	{

			if (min_[nLoop] > WMA_SENSOR [nLoop][nLoop2])	{
				min_[nLoop] = WMA_SENSOR [nLoop][nLoop2];
				minFlag [nLoop] |= 0x1;
			} else if (max_[nLoop] < WMA_SENSOR [nLoop][nLoop2])	{
				max_[nLoop] = WMA_SENSOR [nLoop][nLoop2];
				maxFlag [nLoop] |= 0x1;
			}
			minFlag[nLoop] = minFlag[nLoop] << 1;
			maxFlag[nLoop] = maxFlag[nLoop] << 1;

		}

		gaps [nLoop] = max_ [nLoop] - min_ [nLoop];
		printf ("%d: %d /  ", nLoop, gaps [nLoop]);

		if (gaps [nLoop] > 400)	{
			Motionflag_ |= 0x1;
			temp_flag ++;
			WEIGHTED_AXIS [nLoop] = 90;
		}
		Motionflag_ = Motionflag_ << 1;

	} //for

	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{
		WEIGHTED_AXIS [nLoop] /= temp_flag;
	}

	//printf ("flag: %d\n", flag_);

	if (!Motionflag_ )
		result_ = NONE;
	else if (Motionflag_ == 32)	{
		result_ = FRONT;
	//	WEIGHTED_AXIS [1] = 90;
	}
	else if (Motionflag_ == 64)	{
		result_ = SIDE;
	//	WEIGHTED_AXIS [0] = 90;
	}
	else if (Motionflag_ == 16)	{
	//	WEIGHTED_AXIS [2] = 90;
		result_ = UP;
	}
	else	{
		deriveCorrelation ();
		result_ = compareSelfCorrleation (CLOCK);
	}

	printf ("WEIGHTED: <");
	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{
		printf ("%d,", WEIGHTED_AXIS [nLoop]);
	}
	printf (">\n");

	crossCorrelation ();



	return result_;

}








-------------------------------
#include "em_device.h"
#include "em_chip.h"
#include "em_usart.h"
#include "em_cmu.h"
#include "em_gpio.h"
#include "em_i2c.h"
#include "swCfg.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define WMA_FACTOR	3
//#undef WMA_FACTOR
#define WEIGHT	0.8
#undef WEIGHT
#define NORMALIZATION_FACTOR INT16_MAX

int16_t SENSOR [AXIS_NUM][SAMPLE_NUM];
#ifdef WMA_FACTOR
	#define WMA_SAMPLE_NUM	SAMPLE_NUM - WMA_FACTOR + 1
	int16_t WMA_SENSOR [AXIS_NUM][WMA_SAMPLE_NUM];
	int16_t WMA_temp [AXIS_NUM][WMA_SAMPLE_NUM];

#endif
#define CROSS_FACTOR	3
int8_t WEIGHTED_AXIS [6];
#define NUM_OF_DB	16
#define ELE_OF_DB	2
#define CIRCLE_THRESH	1

enum sensors_	{
	ACC_X,
	ACC_Y,
	ACC_Z,
	GY_X,
	GY_Y,
	GY_Z
};
int biggestValue [NUM_OF_DB];

int corr_int [AXIS_NUM][AXIS_NUM];


///////////////////////////////////////////////////////////////////////
void deriveCorrelation ()	{
///////////////////////////////////////////////////////////////////////
// A factor: The array of sensor data
// Return: NULL
//////////////////////////////////////////////////////////////////////

	float cov [AXIS_NUM][AXIS_NUM];
	float corr [AXIS_NUM][AXIS_NUM];
	float average [] = {0,0,0,0,0,0};
	int nLoop, nLoop2, nLoop3;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			average [nLoop] += SENSOR [nLoop][nLoop2];
		} //for nLoop2
		average [nLoop] /= SAMPLE_NUM;
	} //for nLoop



	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			cov [nLoop][nLoop2] = corr [nLoop][nLoop2] = corr_int[nLoop][nLoop2] = 0;
			for (nLoop3 = 0; nLoop3 < SAMPLE_NUM; nLoop3 ++)	{
				cov [nLoop][nLoop2] += (SENSOR [nLoop][nLoop3] - average [nLoop]) * (SENSOR [nLoop2][nLoop3] - average [nLoop2]);
			} // for nLoop3
			cov [nLoop][nLoop2] /= SAMPLE_NUM;

		} // for nLoop2
	} //for nLoop


	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = nLoop+1; nLoop2 < AXIS_NUM; nLoop2 ++)	{

			if (cov [nLoop][nLoop] * cov [nLoop2][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov [nLoop][nLoop] * cov [nLoop2][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;

			if ((corr [nLoop][nLoop2] < 0.5) && (corr [nLoop][nLoop2] > -0.5))	{	//filtering
				corr [nLoop][nLoop2] = 0;
			} //if
			else	{
				corr_int [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *100);
			}
		} //for nLoop2
	} //for nLoop

/*
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			printf ("%d\t", corr_int [nLoop][nLoop2] );
		}
		printf ("\n");
	}
	printf ("\n");
*/
} //function calculatCorrelation

//////////////////////////////////////////////////////////////////////
int compareSelfCorrleation (int db_id)	{
///////////////////////////////////////////////////////////////////////
// A factor: A DB id among 2, 3, 4, 5, 6, 7, 8, 9, 14, 15
// Return: detected DB id
//////////////////////////////////////////////////////////////////////

	int avg_gap [2] = {0,0};
	int result_ = 0;
	int nLoop, nLoop2, nLoop3;
	int filter_count = 0;
	float MIN = 10000.0;


	int total_db_count [2] = {22, 27};

	int db_corr [2][AXIS_NUM][AXIS_NUM] = {
			{		//for sensor1, CLOCK
					{0, 61, 00, 91, 69, 00 },
					{00, 00, 04, 59, 75, 00 },
					{00, 00, 00, 68, 25, 00 },
					{00, 00, 00, 00, 78, 00 },
					{00, 00, 00, 00, 00, 00 },
					{00, 00, 00, 00, 00, 00 },
				},

				{		//for sensor1, ANTI-CLOCK
					{00, 81, 59, -91, -83, -67 },
					{00, 00, -31, -81, -81, -91 },
					{00, 00, 00, -07, 55, -96 },
					{00, 00, 00, 00, 86, 98 },
					{00, 00, 00, 00, 00, 72 },
					{00, 00, 00, 00, 00, 00 },
				}
		};
	int db_count [2][AXIS_NUM][AXIS_NUM]= {
			{		//for sensor1, CLOCK
				{0, 3, 0, 21, 13, 0 },
				{0, 0, 4, 14, 16, 0 },
				{0, 0, 0, 6, 8, 0 } ,
				{0, 0, 0, 0, 16, 0 },
				{0, 0, 0, 0, 0, 0 },
				{0, 0, 0, 0, 0, 0 },
			},

			{		//for sensor1, ANTI-CLOCK
				{0, 18, 5, 24, 27, 1 },
				{0, 0, 12, 20, 25, 1 },
				{0, 0, 0, 4, 10, 1 },
				{0, 0, 0, 0, 27, 1 },
				{0, 0, 0, 0, 0, 1 },
				{0, 0, 0, 0, 0, 0 },
			},

	};

	for (nLoop = 0; nLoop < 2; nLoop ++)	{

		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			for (nLoop3 = nLoop2 + 1; nLoop3 < AXIS_NUM; nLoop3 ++)	{

				if ((db_count [nLoop][nLoop2][nLoop3] * 5) >  total_db_count [nLoop])	{
					avg_gap [nLoop] += abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]);
					filter_count ++;
					//printf ("%d\t", abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]));
				}


			} //for nLoop3
		} //for nLoop2

		if (filter_count == 0)
			filter_count ++;


		avg_gap [nLoop] /= filter_count;

		filter_count = 0;

		if ((avg_gap [nLoop] != 0) && (MIN > avg_gap [nLoop]))	{
			MIN = avg_gap [nLoop];
		}

	} //for nLoop


	if (avg_gap [0] < avg_gap [1])	{
		result_ = (db_id % 2 == 1) ? (db_id - 1) : (db_id);		//CLOCK
	}
	else	{
		result_ = (db_id % 2 == 1) ? (db_id) : (db_id + 1);		//ANTI-CLOCK
	}

	//printf ("<%d vs. %d> corr result is %d \n",  avg_gap[0],avg_gap[1], result_);

	return result_;
}


#ifdef WMA_FACTOR
void weightedMovingAverage (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{
	int nLoop, nLoop2, nLoop3;
	int16_t temp_avr;

	memset (WMA_SENSOR, '\0', sizeof(WMA_SENSOR));

	//printf ("<< WMA\n");
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < (SAMPLE_NUM - WMA_FACTOR + 1); nLoop2 ++)	{
			temp_avr = 0;
#ifndef WEIGHT
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR; nLoop3 ++)	{
				temp_avr +=  SENSOR [nLoop][nLoop2 + nLoop3];
			}
			WMA_SENSOR [nLoop][nLoop2] = temp_avr / WMA_FACTOR;

#else
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR-1; nLoop3 ++)	{
				temp_avr +=  SENSOR [nLoop][nLoop2 + nLoop3];
			}
			temp_avr *= (1-WEIGHT);
			temp_avr += (WEIGHT * SENSOR [nLoop][nLoop2 + nLoop3]);
			WMA_SENSOR [nLoop][nLoop2] = temp_avr;
#endif
			//printf ("(%d)%d  ", nLoop2, WMA_SENSOR [nLoop][nLoop2]);
		}
		//printf ("\n");
	}
	//printf ("\n");
}
#endif



void compareOtherCorrelation (int arrayLen, int flag_, float db_sample[ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM], float db_average[ELE_OF_DB][AXIS_NUM], float db_cov[ELE_OF_DB][AXIS_NUM])	{

	int16_t WMA_SENSOR_local [AXIS_NUM][WMA_SAMPLE_NUM];
	int nLoopLen = 0, nLoopStart = 0;//, db_start = 0, db_end = 0;
	float average [AXIS_NUM];
	int nLoop, nLoop2, nLoop3;
	float cov [ELE_OF_DB][AXIS_NUM];
	float cov_self [AXIS_NUM];
	float corr [ELE_OF_DB][AXIS_NUM];
	float corr_int_local [ELE_OF_DB][AXIS_NUM];

	memset (cov, '\0', sizeof(cov));
	memset (average, '\0', sizeof(average));
	memset (cov_self, '\0', sizeof(cov_self));
	memset (corr, '\0', sizeof(corr));
	memset (corr_int_local, '\0', sizeof (corr_int_local));


	memset (WMA_SENSOR_local, '\0', sizeof(WMA_SENSOR_local));
	if (flag_ < 1)	{
		nLoopLen = arrayLen;
		nLoopStart = 0;
		memcpy (WMA_SENSOR_local, WMA_temp, sizeof(WMA_SENSOR_local));
	}
	else	{
		nLoopLen = WMA_SAMPLE_NUM;
		nLoopStart = flag_;
		memcpy (WMA_SENSOR_local, WMA_SENSOR, sizeof(WMA_SENSOR_local));
	}
/*
	switch (semi_result)	{
	case FRONT:
		db_start = FRONT;
		db_end = BACK;
		break;
	case SIDE:
		db_start = RIGHT;
		db_end = LEFT;
		break;
	case UP:
		db_start = UP;
		db_end = DOWN;
		break;
	default:
		db_start = CLOCK;
		db_end = SIDE_ANTI;
		break;
	}
	db_start = 0;
	db_end = NUM_OF_DB-1;


	int i;
	printf ("db_sample\n");
for (i = 0; i < 2; i ++)	{
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM; nLoop2 ++)	{
			printf ("%d ",(int)(db_sample[i][nLoop][nLoop2] * 10000));

		}
		printf ("\n");

	}
	printf ("\n");
}
	printf ("average & cov\n");
	for (i = 0; i < 2; i ++)	{

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		printf ("%d/%d ",(int)(db_average[i][nLoop] * 10000), (int)(db_cov [i][nLoop] * 10000));

	}		printf ("\n");
	}


*/

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{	//average of incoming sensor value
		for (nLoop2 = 0; nLoop2 < nLoopLen ; nLoop2 ++)	{
			average [nLoop] += WMA_SENSOR_local [nLoop][nLoop2];
		} //for nLoop2

		average [nLoop] /= nLoopLen;

	} //for nLoop

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		float temp_float=0;
		for (nLoop2 = nLoopStart; nLoop2 < nLoopLen; nLoop2 ++)	{ //covariance //분자계산
			temp_float = WMA_SENSOR_local [nLoop][nLoop2 - nLoopStart] - average [nLoop];

			for (nLoop3 = 0; nLoop3 < ELE_OF_DB; nLoop3 ++)
				cov [nLoop3][nLoop] += (temp_float * (db_sample [nLoop3][nLoop][nLoop2] - db_average [nLoop3][nLoop]));


			cov_self [nLoop] += (temp_float * temp_float);

		} //for nLoop2

		for (nLoop3 = 0; nLoop3 < ELE_OF_DB; nLoop3 ++)
			cov [nLoop3][nLoop] /= (nLoopLen - nLoopStart);

		cov_self [nLoop] /= (nLoopLen - nLoopStart);
	} // for nLoop

	int tempSUM [ELE_OF_DB];
	memset (tempSUM, 0, sizeof(tempSUM));
	//	printf ("----------------\ncorrelation(len: %d, flag: %d\n", arrayLen, flag_);

	//for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{	//correlation. //분모 계산
		for (nLoop = 0; nLoop <= 1; nLoop ++)	{	//correlation. //분모 계산

	//		printf ("(%d db)\t", nLoop);

		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			if (cov_self [nLoop2] * db_cov [nLoop][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov_self [nLoop2] * db_cov [nLoop][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;

			corr_int_local [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *100);
	//			printf ("%d(%d) ", (int)corr_int_local [nLoop][nLoop2], ((int)(corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2]) / 100));

			tempSUM [nLoop] += ((int)(corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2]) / 100);

		} //for nLoop2
			//printf (" --> %d \n", tempSUM[nLoop]);

		if (tempSUM[nLoop] < 20)
			 tempSUM[nLoop] = 0;
		else
			tempSUM[nLoop] *= tempSUM[nLoop];
	} //for nLoop

	/*------------------------------------------------ deviation --------------
		int gap_mean [NUM_OF_DB][AXIS_NUM];
		int gap_deviation [NUM_OF_DB][AXIS_NUM];
		memset (gap_mean, 0x0, sizeof(gap_mean));
		memset (gap_deviation, 0x0, sizeof(gap_deviation));


		int tempSUM_dev [NUM_OF_DB];
		memset (tempSUM_dev, 0, sizeof(tempSUM_dev));

	//	printf ("GAP dev!\n");

		//for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{
		for (nLoop = 0; nLoop <= 1; nLoop ++)	{
			for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++){
				for (nLoop3 = nLoopStart; nLoop3 < nLoopLen; nLoop3 ++){
					gap_mean [nLoop][nLoop2] += abs( (int)(db_sample [nLoop][nLoop2][nLoop3] * 1000) - (int) WMA_SENSOR_local[nLoop2][nLoop3]);
				}
				gap_mean [nLoop][nLoop2] /= nLoopLen;

				for (nLoop3 = nLoopStart; nLoop3 < nLoopLen; nLoop3 ++){
					gap_deviation [nLoop][nLoop2] += abs( (int)(db_sample [nLoop][nLoop2][nLoop3] * 1000) - (int)WMA_SENSOR_local[nLoop2][nLoop3] - (int)gap_mean [nLoop][nLoop2] );
				}

				gap_deviation [nLoop][nLoop2] /= nLoopLen;
		//			printf ("(%d:%d)%d ", nLoop, nLoop2, gap_deviation [nLoop][nLoop2]);

				tempSUM_dev [nLoop] +=  gap_deviation [nLoop][nLoop2];
			}
		//	printf (" ==) %d\n", tempSUM_dev [nLoop]);

		}
		//	printf ("\n");

*/
		int temp_int;
		//printf ("result is ");
		for (nLoop = 0; nLoop <= 1; nLoop ++)	{
			if (tempSUM [nLoop] > 0)	{
			//	temp_int = (int)((tempSUM [nLoop] * 1000) / tempSUM_dev [nLoop]);
				temp_int = tempSUM [nLoop];
				//printf ("(%d)%d-%d, ", nLoop, tempSUM [nLoop], temp_int);

			}
			else	{
				temp_int = 0;
		//		printf ("0, ");
			}

			if (biggestValue [nLoop] < temp_int)
				biggestValue [nLoop] = temp_int;
		}
		//printf ("\n");

}


void normalizingFunction (int16_t sensor [AXIS_NUM][SAMPLE_NUM]){
	int nLoop, nLoop2;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			SENSOR [nLoop][nLoop2] = (int)(((float)sensor [nLoop][nLoop2] / NORMALIZATION_FACTOR) * 1000);
		}
	}

}




int crossCorrelation (float db_sample[ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM], float db_average[ELE_OF_DB][AXIS_NUM], float db_cov[ELE_OF_DB][AXIS_NUM])	{

	int nLoop, nLoop2, max_ = 0, db_num = 0, result_ = 0;
	memset (WMA_temp, '\0', sizeof(WMA_SAMPLE_NUM));
	biggestValue [0] = biggestValue [1] = 0;


	for (nLoop = -CROSS_FACTOR; nLoop < 1; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM + nLoop ; nLoop2 ++)	{
			WMA_temp [0][nLoop2] = WMA_SENSOR [0][-nLoop+ nLoop2];
			WMA_temp [1][nLoop2] = WMA_SENSOR [1][-nLoop+ nLoop2];
			WMA_temp [2][nLoop2] = WMA_SENSOR [2][-nLoop+ nLoop2];
			WMA_temp [3][nLoop2] = WMA_SENSOR [3][-nLoop+ nLoop2];
			WMA_temp [4][nLoop2] = WMA_SENSOR [4][-nLoop+ nLoop2];
			WMA_temp [5][nLoop2] = WMA_SENSOR [5][-nLoop+ nLoop2];
		}
		compareOtherCorrelation (WMA_SAMPLE_NUM + nLoop, nLoop, db_sample, db_average, db_cov);
	}
	for (nLoop = 1; nLoop < CROSS_FACTOR; nLoop ++)	{
		compareOtherCorrelation (WMA_SAMPLE_NUM, nLoop, db_sample, db_average, db_cov);
	}

	printf ("biggest value: ");
	for (nLoop = 0; nLoop < ELE_OF_DB; nLoop ++)	{
		printf ("%d ",  biggestValue [nLoop]);
		if (biggestValue [nLoop] > max_)	{
			max_ = biggestValue [nLoop];
			db_num = nLoop;
		}
	}
	printf ("\n");


	result_ = biggestValue [0] > biggestValue [1] ? 0 : 1;
	return result_;

}



int assignDB_FRONT (void)	{
	int result_;
	printf ("\nassign DB Front\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{ //front
			{-0.0120 ,-0.0290 ,-0.0990 ,-0.0850 ,-0.0360 ,0.1230 ,0.1430 ,0.0860 ,0.0450 ,0.0780 ,0.1370 ,0.1210 ,0.0620 ,0.0290 ,0.0170 ,0.0140 ,0.0080 ,-0.0230 },
			{0.0300 ,0.0890 ,0.2420 ,0.3830 ,0.4060 ,0.2090 ,-0.1160 ,-0.3530 ,-0.3880 ,-0.2590 ,-0.1710 ,-0.1680 ,-0.1700 ,-0.0820 ,0.0090 ,0.0750 ,0.1080 ,0.1060},
			{0.5030 ,0.5110 ,0.4470 ,0.5130 ,0.4920 ,0.5650 ,0.4880 ,0.4540 ,0.4350 ,0.4370 ,0.4890 ,0.5240 ,0.4930 ,0.4720 ,0.4580 ,0.5010 ,0.5190 ,0.5060 },
			{0.0000 ,-0.0040 ,-0.0010 ,-0.0050 ,-0.0090 ,-0.0010 ,-0.0240 ,-0.0330 ,-0.0350 ,0.0000 ,0.0190 ,0.0150 ,0.0190 ,0.0350 ,0.0310 ,0.0140 ,-0.0020 ,-0.0090},
			{0.0000 ,0.0010 ,-0.0150 ,-0.0380 ,-0.0540 ,-0.0320 ,0.0160 ,0.0340 ,0.0010 ,-0.0130 ,-0.0080 ,0.0300 ,0.0210 ,0.0060 ,-0.0060 ,-0.0010 ,0.0160 ,0.0200 },
			{0.0000 ,-0.0040 ,-0.0320 ,-0.0250 ,-0.0270 ,-0.0130 ,-0.0410 ,-0.0420 ,-0.0200 ,0.0070 ,0.0240 ,0.0300 ,0.0380 ,0.0410 ,0.0330 ,0.0210 ,0.0080 ,0.0050}
		},
		{// back
			{0.0380 ,0.0650 ,0.0630 ,0.0790 ,0.0650 ,0.0470 ,0.0120 ,-0.0310 ,-0.0500 ,-0.0710 ,-0.0510 ,-0.0230 ,0.0050 ,0.0160 ,0.0200 ,0.0160 ,0.0130 ,0.0120},
			{-0.0240 ,-0.1110 ,-0.2300 ,-0.2890 ,-0.2000 ,0.0650 ,0.3430 ,0.4490 ,0.3320 ,0.1480 ,0.0450 ,0.0240 ,0.0220 ,0.0100 ,0.0020 ,0.0060 ,0.0140 ,0.0220 },
			{0.5120 ,0.5280 ,0.5080 ,0.5090 ,0.4570 ,0.4840 ,0.4780 ,0.4930 ,0.5150 ,0.5610 ,0.5720 ,0.5320 ,0.4950 ,0.5140 ,0.5220 ,0.5170 ,0.5090 ,0.5080 },
			{0.0020 ,0.0070 ,0.0140 ,0.0160 ,0.0140 ,-0.0020 ,0.0040 ,0.0010 ,0.0070 ,-0.0070 ,-0.0090 ,-0.0110 ,-0.0080 ,-0.0060 ,-0.0020 ,0.0010 ,0.0010 ,0.0000},
			{0.0010 ,0.0010 ,-0.0050 ,-0.0060 ,0.0000 ,0.0260 ,0.0620 ,0.0480 ,0.0110 ,-0.0260 ,-0.0230 ,-0.0090 ,-0.0150 ,-0.0110 ,-0.0060 ,0.0000 ,0.0020 ,0.0010 },
			{0.0010 ,0.0040 ,0.0150 ,0.0360 ,0.0450 ,0.0360 ,0.0140 ,-0.0100 ,-0.0180 ,-0.0170 ,-0.0020 ,0.0070 ,0.0060 ,0.0030 ,-0.0020 ,-0.0040 ,-0.0040 ,-0.0020 }

		},
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0322,-0.0028,0.4893,0.0006,-0.0012,0.0002},	//front
			{0.0125,0.0349,0.5119,0.0012,0.0028,0.0060}	//back
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.00534, 0.05293, 0.00114, 0.00037, 0.00054, 0.00074},	//front
			{0.00191, 0.03687, 0.00073, 0.00006, 0.00050, 0.00030}	//back
	};

/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = BACK;
	else
		result_ = FRONT;

	return result_;
	*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}

int assignDB_RIGHT (void)	{
	int result_;
	printf ("\nassign DB Right\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{ //right
			{0.0540 , 0.1750 , 0.3180 , 0.3830 , 0.2940 , 0.0710 , -0.1720 , -0.3040 , -0.2730 , -0.1470 , -0.0280 , 0.0250 , 0.0360 , 0.0400 , 0.0510 , 0.0640 , 0.0740 , 0.0780 },
			{-0.0150 , 0.0130 , 0.0270 , 0.0420 , -0.0120 , -0.0760 , -0.1430 , -0.1340 , -0.0760 , -0.0120 , 0.0320 , 0.0430 , 0.0330 , 0.0200 , 0.0220 , 0.0280 , 0.0380 , 0.0380 },
			{0.5100 , 0.5400 , 0.5730 , 0.5340 , 0.4940 , 0.4110 , 0.4790 , 0.5210 , 0.5850 , 0.5470 , 0.5180 , 0.4950 , 0.4940 , 0.5050 , 0.5150 , 0.5140 , 0.5060 , 0.5010},
			{0.0020 , 0.0060 , 0.0170 , 0.0300 , 0.0310 , 0.0220 , -0.0020 , -0.0120 , -0.0150 , -0.0030 , 0.0030 , 0.0030 , 0.0000 , -0.0030 , -0.0030 , -0.0010 , 0.0010 , 0.0000},
			{-0.0050 , -0.0150 , -0.0220 , -0.0170 , -0.0060 , -0.0130 , -0.0330 , -0.0400 , -0.0230 , -0.0020 , 0.0040 , 0.0030 , 0.0000 , -0.0040 , -0.0030 , -0.0010 , 0.0000 , -0.0010},
			{0.0000 , -0.0080 , -0.0290 , -0.0670 , -0.1030 , -0.1260 , -0.1080 , -0.0680 , -0.0200 , 0.0060 , 0.0110 , 0.0080 , 0.0040 , 0.0060 , 0.0090 , 0.0090 , 0.0060 , 0.0030}
		},
		{ //left
			{0.009000 , -0.090000 , -0.243000 , -0.299000 , -0.184000 , 0.047000 , 0.253000 , 0.367000 , 0.361000 , 0.250000 , 0.112000 , 0.031000 , 0.014000 , 0.012000 , 0.016000 , 0.021000 , 0.032000 , 0.037000},
			{0.002000 , 0.016000 , -0.046000 , -0.080000 , -0.091000 , -0.036000 , 0.022000 , 0.050000 , 0.056000 , 0.027000 , -0.024000 , -0.043000 , -0.040000 , -0.039000 , -0.032000 , -0.024000 , -0.022000 , -0.024000 },
			{0.510000 , 0.521000 , 0.567000 , 0.559000 , 0.526000 , 0.471000 , 0.436000 , 0.464000 , 0.486000 , 0.496000 , 0.505000 , 0.506000 , 0.535000 , 0.519000 , 0.500000 , 0.507000 , 0.515000 , 0.524000 },
			{0.002000 , 0.011000 , 0.015000 , 0.012000 , -0.001000 , -0.007000 , -0.006000 , -0.007000 , -0.006000 , -0.013000 , -0.011000 , -0.012000 , -0.005000 , -0.003000 , -0.002000 , -0.003000 , -0.004000 , -0.004000 },
			{-0.002000 , -0.005000 , -0.003000 , 0.007000 , 0.009000 , 0.008000 , -0.002000 , -0.009000 , 0.000000 , 0.006000 , 0.009000 , 0.002000 , -0.002000 , 0.003000 , 0.001000 , 0, 0 , 0.001000 },
			{0, 0, 0.008000 , 0.042000 , 0.082000 , 0.105000 , 0.087000 , 0.042000 , 0.004000 , -0.021000 , -0.026000 , -0.025000 , -0.020000 , -0.013000 , -0.010000 , -0.007000 , -0.006000 , -0.005000 }

		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0411, -0.0073, 0.5134, 0.0042, -0.0099, -0.0259},	//right
			{0.04144, -0.0182, 0.5082, -0.0024, 0.0013, 0.0132} 	//left
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.0343, 0.0036, 0.0014, 0.0002, 0.0002, 0.0022}, 	//right
			{0.03354, 0.0016, 0.0010, 0.0001, 0.00001, 0.0017} //left
	};

/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ =LEFT ;
	else
		result_ = RIGHT;
	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}

int assignDB_UP (void)	{
	int result_;
	printf ("\nassign DB UP\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
			{	//UP
				{0.0040 , 0.0110 , 0.0220 , 0.0280 , 0.0180 , -0.0080 , -0.0260 , -0.0310 , -0.0200 , -0.0100 , -0.0060 , -0.0080 , -0.0120 , -0.0140 , -0.0080 , 0.0010 , 0.0100 , 0.0140},
				{-0.0430 , -0.0610 , -0.0090 , -0.0230 , -0.0010 , -0.0740 , -0.0390 , 0.0110 , 0.0630 , 0.0740 , 0.0750 , 0.0720 , 0.0650 , 0.0580 , 0.0590 , 0.0620 , 0.0680 , 0.0700},
				{0.5120 , 0.5790 , 0.7410 , 0.8000 , 0.6800 , 0.3420 , 0.1240 , 0.0810 , 0.2040 , 0.3460 , 0.4540 , 0.5140 , 0.5540 , 0.5490 , 0.5430 , 0.5190 , 0.5150 , 0.5050},
				{-0.0030 , -0.0300 , -0.0040 , 0.0200 , 0.0610 , 0.0460 , 0.0310 , 0.0190 , 0.0070 , -0.0050 , -0.0110 , -0.0110 , -0.0080 , -0.0030 , 0.0020 , 0.0040 , 0.0050 , 0.0030},
				{0.0000 , -0.0110 , -0.0050 , 0.0020 , 0.0240 , 0.0250 , 0.0110 , -0.0040 , -0.0140 , -0.0120 , -0.0100 , -0.0080 , -0.0050 , -0.0010 , 0.0000 , 0.0000 , 0.0020 , 0.0030},
				{0.0000 , 0.0110 , 0.0190 , 0.0230 , 0.0070 , -0.0090 , -0.0180 , -0.0170 , -0.0130 , -0.0090 , -0.0070 , -0.0050 , -0.0030 , -0.0010 , 0.0010 , 0.0020 , 0.0020 , 0.0010}

			},
			{	//down
				{-0.0240 , -0.0470 , -0.0970 , -0.0870 , 0.0180 , 0.1270 , 0.1350 , 0.0690 , 0.0280 , 0.0160 , 0.0100 , 0.0000 , -0.0060 , 0.0000 , 0.0110 , 0.0200 , 0.0180 , 0.0120 },
				{0.0500 , 0.0210 , 0.0260 , -0.0430 , 0.0090 , 0.0010 , 0.0250 , -0.0260 , -0.0530 , -0.0290 , -0.0390 , -0.0400 , -0.0420 , -0.0420 , -0.0430 , -0.0430 , -0.0500 , -0.0420},
				{0.4500 , 0.2100 , -0.0560 , -0.0340 , 0.3720 , 0.8250 , 0.8800 , 0.7350 , 0.5840 , 0.5360 , 0.5120 , 0.4930 , 0.4930 , 0.4970 , 0.5140 , 0.5230 , 0.5180 , 0.4990},
				{0.0170 , 0.0120 , -0.0150 , -0.0590 , -0.0980 , -0.0930 , -0.0580 , -0.0240 , -0.0060 , -0.0060 , 0.0000 , 0.0010 , 0.0000 , -0.0020 , -0.0050 , -0.0040 , 0.0000 , 0.0060},
				{0.0500 , 0.0810 , 0.0410 , -0.0700 , -0.1190 , -0.0700 , 0.0080 , 0.0180 , -0.0030 , -0.0060 , -0.0040 , -0.0040 , -0.0040 , -0.0040 , -0.0030 , 0.0030 , 0.0070 , 0.0060},
				{0.0020 , 0.0050 , 0.0060 , 0.0050 , 0.0080 , 0.0000 , 0.0010 , -0.0060 , 0.0000 , 0.0000 , 0.0010 , 0.0000 , 0.0000 , 0.0000 , 0.0010 , 0.0000 , -0.0010 , -0.0010},
			}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{-0.0019, 0.0237, 0.4757, 0.0068, -0.0002, -0.0009},	//up
			{0.0113, -0.0200, 0.4751, -0.0186, -0.0041, 0.0012} 	//down
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.0003, 0.0028, 0.0376, 0.0005, 0.0001, 0.0001}, 	//up
			{0.0035, 0.0011, 0.0589, 0.0012, 0.0021, 0.00001}	//down
	};

/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = DOWN;
	else
		result_ = UP;
	return result_;
	*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}

int assignDB_CLOCK (void)	{
	int result_;
	printf ("\nassign DB Clk\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{ //CLOCK
			{0.0955 , 0.2635 , 0.3904 , 0.4570 , 0.4397 , 0.2961 , 0.0711 , -0.2096 , -0.4202 , -0.5015 , -0.3693 , -0.1749 , 0.0070 , 0.0755 , 0.0992 , 0.0825 , 0.0641 , 0.0245 },
			{-0.0409 , -0.0365 , -0.0492 , -0.0303 , -0.0183 , -0.0530 , -0.0996 , -0.1998 , -0.2290 , -0.2101 , -0.1068 , -0.0007 , 0.0223 , 0.0035 , -0.0563 , -0.0780 , -0.0772 , -0.0604 },
			{0.9343 , 0.8526 , 0.6681 , 0.3260 , 0.1101 , -0.0960 , -0.1095 , -0.0322 , 0.2818 , 0.5574 , 0.7934 , 0.8148 , 0.8499 , 0.7628 , 0.7038 , 0.6051 , 0.5729 , 0.5071 },
			{0.0949 , 0.1808 , 0.2183 , 0.1990 , 0.1479 , 0.0787 , -0.0041 , -0.0802 , -0.1401 , -0.1749 , -0.1750 , -0.1497 , -0.1059 , -0.0689 , -0.0285 , -0.0084 , 0.0057 , 0.0033 },
			{-0.0535 , -0.0383 , 0.0024 , 0.0002 , -0.0190 , -0.0616 , -0.0948 , -0.1254 , -0.1309 , -0.0935 , -0.0330 , 0.0154 , 0.0333 , 0.0384 , 0.0279 , 0.0194 , 0.0102 , 0.0106 },
			{0.1447 , 0.0909 , 0.0195 , -0.0454 , -0.1270 , -0.1813 , -0.2095 , -0.1864 , -0.1162 , -0.0189 , 0.0760 , 0.1204 , 0.1333 , 0.1138 , 0.0885 , 0.0553 , 0.0289 , 0.0085 }

		},
		{ //ANTI-CLOCK
			{0.1536 , -0.2041 , -0.3660 , -0.3371 , -0.2394 , -0.1310 , -0.0166 , 0.0971 , 0.1728 , 0.2668 , 0.3068 , 0.2842 , 0.1848 , 0.0856 , 0.0062 , -0.0730 , -0.1335 , -0.1470 },
			{-0.1114 , -0.3936 , -0.4661 , -0.4337 , -0.2992 , -0.1715 , -0.0327 , 0.0819 , 0.1073 , 0.0832 , 0.0411 , 0.0020 , -0.0990 , -0.1627 , -0.1772 , -0.1342 , -0.1240 , -0.1206 },
			{0.8617 , 0.9261 , 0.8838 , 0.6318 , 0.3124 , 0.0442 , -0.0956 , -0.1198 , 0.0114 , 0.2855 , 0.5566 , 0.7435 , 0.7857 , 0.7948 , 0.7607 , 0.6815 , 0.5950 , 0.5346 },
			{0.0273 , 0.0842 , 0.1378 , 0.1700 , 0.1474 , 0.0836 , 0.0106 , -0.0626 , -0.1188 , -0.1643 , -0.1755 , -0.1649 , -0.1205 , -0.0654 , -0.0207 , 0.0017 , 0.0102 , 0.0143 },
			{0.0063 , 0.0011 , 0.0328 , 0.0913 , 0.1344 , 0.1259 , 0.1043 , 0.0681 , 0.0230 , -0.0114 , -0.0069 , 0.0084 , 0.0073 , -0.0097 , -0.0118 , 0.0063 , 0.0124 , 0.0131 },
			{-0.2334 , -0.2022 , -0.0971 , 0.0079 , 0.0877 , 0.1477 , 0.1952 , 0.1990 , 0.1613 , 0.1021 , 0.0317 , -0.0307 , -0.0822 , -0.1063 , -0.1069 , -0.0932 , -0.0673 , -0.0412 	}
		},
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0384, -0.0733, 0.5057, -0.0004, -0.0273, -0.0003}, //clock
			{-0.0050, -0.1339, 0.5108, -0.0114, 0.0330, -0.0071} //ANTI-clock
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.0759, 0.0050, 0.1121, 0.0158, 0.0028, 0.0131},	//CLOCK
			{0.0421, 0.0285, 0.1158, 0.0114, 0.0023, 0.0163}	//ANTI-CLOCK
	};

/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = ANTI_CLOCK;
	else
		result_ = CLOCK;
	return result_;
	*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}

int assignDB_LOW (void)	{
	int result_;
	printf ("\nassign DB Low\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{ //LOW CLOCK
			{0.3006 , 0.3424 , 0.3616 , 0.3218 , 0.2365 , 0.1268 , 0.0348 , -0.0595 , -0.1366 , -0.2006 , -0.2176 , -0.1927 , -0.1407 , -0.0507 , 0.0183 , 0.0903 , 0.0999 , 0.0949 },
			{0.1700 , 0.1202 , -0.0088 , -0.1808 , -0.2990 , -0.3368 , -0.2961 , -0.2510 , -0.1992 , -0.1522 , -0.0834 , -0.0190 , 0.0253 , 0.0719 , 0.0642 , 0.0596 , 0.0109 , -0.0116},
			{0.5936 , 0.5105 , 0.4762 , 0.4848 , 0.4739 , 0.4619 , 0.4485 , 0.4307 , 0.4674 , 0.5326 , 0.6218 , 0.6579 , 0.6215 , 0.5714 , 0.5328 , 0.5451 , 0.5481 , 0.5459},
			{0.0424 , 0.0388 , 0.0259 , 0.0277 , 0.0150 , 0.0089 , -0.0023 , -0.0146 , -0.0343 , -0.0444 , -0.0397 , -0.0220 , -0.0053 , 0.0012 , 0.0016 , 0.0028 , 0.0026 , 0.0015},
			{-0.0209 , -0.0085 , -0.0046 , 0.0032 , 0.0024 , -0.0102 , -0.0248 , -0.0350 , -0.0387 , -0.0340 , -0.0158 , 0.0087 , 0.0263 , 0.0258 , 0.0199 , 0.0114 , 0.0149 , 0.0144 },
			{0.0545 , -0.0140 , -0.0798 , -0.1114 , -0.1173 , -0.0899 , -0.0649 , -0.0461 , -0.0343 , -0.0190 , 0.0032 , 0.0261 , 0.0493 , 0.0662 , 0.0693 , 0.0661 , 0.0546 , 0.0458}
		},
		{ //LOW ANTI
			{0.1573 , 0.0709 , -0.0684 , -0.1793 , -0.2324 , -0.2304 , -0.1262 , 0.0454 , 0.2397 , 0.3674 , 0.4178 , 0.4139 , 0.3993 , 0.3387 , 0.2261 , 0.0797 , -0.0449 , -0.0944 },
			{0.1311 , 0.1593 , 0.0867 , -0.0606 , -0.2740 , -0.4536 , -0.5189 , -0.4771 , -0.3686 , -0.2549 , -0.1614 , -0.0310 , 0.0442 , 0.1334 , 0.1017 , 0.0703 , -0.0309 , -0.0758},
			{0.5781 , 0.6344 , 0.6500 , 0.7000 , 0.5991 , 0.5298 , 0.3672 , 0.3612 , 0.3605 , 0.3965 , 0.4605 , 0.5343 , 0.5890 , 0.6164 , 0.6203 , 0.6092 , 0.5857 , 0.5742 },
			{-0.0082 , -0.0014 , -0.0030 , 0.0220 , 0.0284 , 0.0448 , 0.0199 , 0.0129 , -0.0040 , -0.0155 , -0.0296 , -0.0421 , -0.0619 , -0.0673 , -0.0563 , -0.0247 , 0.0031 , 0.0179},
			{-0.0161 , -0.0257 , -0.0311 , -0.0139 , 0.0320 , 0.0536 , 0.0532 , 0.0122 , -0.0107 , -0.0320 , -0.0445 , -0.0323 , 0.0026 , 0.0309 , 0.0284 , 0.0062 , -0.0175 , -0.0177 },
			{-0.0617 , -0.1022 , -0.1290 , -0.1193 , -0.0908 , -0.0126 , 0.0854 , 0.1786 , 0.2294 , 0.2139 , 0.1750 , 0.1055 , 0.0399 , -0.0448 , -0.1064 , -0.1503 , -0.1464 , -0.1117 }
		},
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0572, -0.0731, 0.5291, 0.0003, -0.0036, -0.0079}, //LOW CLOCK
			{0.0989, -0.1100, 0.5426, -0.0092, -0.0012, -0.0026} //LOW ANTI
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.0363, 0.0232, 0.0041, 0.0006, 0.0004, 0.0040},	//LOW CLOCK
			{0.0498, 0.0491, 0.0108, 0.0010, 0.0009, 0.0169}	//LOW ANTI
	};

/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = LOW_ANTI;
	else
		result_ = LOW_CLOCK;
	return result_;
	*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));

}

int assignDB_SIDE ()	{

	int result_;
	printf ("\nassign DB Side\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{	//SIDE-CLK
			{0.0110 , 0.0720 , 0.1490 , 0.1750 , 0.1200 , 0.0560 , 0.0450 , 0.1130 , 0.1660 , 0.1770 , 0.1330 , 0.1240 , 0.1910 , 0.2280 , 0.2730 , 0.2270 , 0.1580 , 0.0660 },
			{0.0520 , 0.0350 , -0.1210 , -0.3610 , -0.5450 , -0.5440 , -0.3260 , 0.0290 , 0.3610 , 0.5520 , 0.4910 , 0.3100 , 0.1120 , -0.0080 , -0.0760 , -0.2050 , -0.3110 , -0.3360 },
			{0.4590 , 0.6430 , 0.8420 , 0.9320 , 0.6840 , 0.3330 , -0.0450 , -0.1830 , -0.2640 , -0.1010 , 0.1440 , 0.5300 , 0.8140 , 0.9220 , 0.8160 , 0.6400 , 0.4800 , 0.4310 },
			{-0.0220 , -0.0260 , 0.0110 , 0.0820 , 0.1400 , 0.1510 , 0.1090 , 0.0270 , -0.0590 , -0.1350 , -0.1970 , -0.2030 , -0.1460 , -0.0460 , 0.0160 , 0.0450 , 0.0230 , 0.0080 },
			{-0.0230 , -0.0430 , 0.0030 , 0.0890 , 0.1660 , 0.1630 , 0.0950 , 0.0350 , -0.0120 , -0.0470 , -0.0610 , -0.0890 , -0.0850 , -0.0710 , -0.0090 , 0.0380 , 0.0580 , 0.0420 },
			{-0.0090 , -0.0230 , -0.0430 , -0.0370 , 0.0090 , 0.0880 , 0.1430 , 0.1550 , 0.1130 , 0.0330 , -0.0390 , -0.0800 , -0.0930 , -0.0870 , -0.0840 , -0.0690 , -0.0550 , -0.0260 }
		},
		{	//SIDE-ANTI
			{0.0110 , 0.0100 , 0.0210 , 0.0520 , 0.1120 , 0.1620 , 0.1790 , 0.1020 , -0.0460 , -0.1480 , -0.1840 , -0.1070 , -0.0430 , 0.0100 , 0.0450 , 0.0860 , 0.1370 , 0.1500 },
			{-0.0190 , -0.0400 , -0.1110 , -0.2290 , -0.3390 , -0.3480 , -0.2930 , -0.1610 , -0.0380 , 0.2160 , 0.4010 , 0.5070 , 0.3370 , 0.0480 , -0.2390 , -0.4040 , -0.4230 , -0.3330 },
			{0.4810 , 0.4110 , 0.3430 , 0.3240 , 0.4810 , 0.6930 , 0.9020 , 0.8350 , 0.7220 , 0.4140 , 0.3500 , 0.1240 , 0.0780 , -0.0810 , 0.0350 , 0.1930 , 0.4090 , 0.5430 },
			{0.0050 , -0.0070 , -0.0340 , -0.0730 , -0.0940 , -0.0860 , -0.0290 , 0.0740 , 0.1660 , 0.1860 , 0.1510 , 0.0880 , 0.0470 , -0.0230 , -0.0900 , -0.1440 , -0.1490 , -0.1120 },
			{0.0000 , -0.0100 , -0.0200 , -0.0390 , -0.0470 , -0.0080 , 0.0690 , 0.1180 , 0.1000 , 0.0630 , 0.0200 , 0.0120 , -0.0260 , -0.0460 , -0.0850 , -0.0960 , -0.0880 , -0.0780 },
			{-0.0130 , -0.0120 , -0.0040 , 0.0050 , 0.0210 , 0.0310 , 0.0360 , 0.0310 , 0.0350 , 0.0560 , 0.0550 , 0.0240 , -0.0320 , -0.0610 , -0.0530 , -0.0190 , 0.0140 , 0.0340 }
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.1380, -0.0495, 0.4487, -0.0123, 0.0138, -0.0058},	//side-clk
			{0.0305, -0.0816, 0.4032, -0.0069, -0.0089, 0.0082} 	//side-anti
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.00490, 0.10865, 0.1516, 0.01107, 0.00612, 0.00641},	//side-clk
			{0.01116, 0.08157, 0.07431, 0.01101, 0.00406, 0.00117}	//side-anti

	};
/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = SIDE_ANTI;
	else
		result_ = SIDE_CLOCK;

	return result_;
	*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}




int assignDB_FRONT_RL ()	{

	int result_;
	printf ("\nassign DB FRONT-RightLeft\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{	//FRONT-RIGHT
			{-0.001, -0.03, -0.016, 0.01, 0.112, 0.035, 0.061, 0.154, 0.463, 0.606, 0.414, -0.044, -0.423, -0.468, -0.259, -0.072, 0.023, 0.05},
			{-0.023, 0.055, 0.218, 0.259, -0.019, -0.376, -0.498, -0.302, -0.029, 0.087, -0.035, -0.27, -0.352, -0.231, -0.02, 0.03, 0.057, 0.019},
			{0.461, 0.499, 0.531, 0.529, 0.504, 0.479, 0.499, 0.506, 0.536, 0.51, 0.461, 0.499, 0.531, 0.529, 0.504, 0.479, 0.499, 0.506},
			{-0.022, -0.05, -0.064, -0.012, 0.07, 0.079, 0.043, 0.013, 0.033, 0.021, -0.008, -0.022, -0.02, -0.005, 0.001, 0.01, 0.005, 0.002},
			{-0.007, -0.018, -0.035, -0.016, 0.051, 0.079, 0.025, -0.047, -0.067, -0.029, -0.002, 0.001, 0.011, -0.003, 0, -0.012, -0.011, -0.01},
			{0.005, 0.009, 0.01, -0.021, -0.039, -0.038, 0.015, 0.047, 0.044, -0.044, -0.158, -0.199, -0.135, -0.023, 0.031, 0.038, 0.027, 0.015}
		},
		{	//FRONT-LEFT
			{-0.033, -0.049, -0.047, 0.008, 0.131, 0.073, 0.03, -0.119, -0.245, -0.437, -0.29, 0.123, 0.467, 0.438, 0.24, 0.092, 0.021, -0.004},
			{-0.024, 0.053, 0.224, 0.398, 0.255, -0.211, -0.475, -0.431, -0.236, -0.28, -0.208, -0.081, 0.077, 0.011, -0.03, -0.079, -0.085, -0.074},
			{0.509, 0.534, 0.698, 0.721, 0.621, 0.359, 0.365, 0.439, 0.583, 0.553, 0.494, 0.41, 0.425, 0.479, 0.52, 0.532, 0.547, 0.548},
			{-0.004, -0.012, -0.007, 0.002, 0.057, 0.021, 0.002, -0.043, -0.025, -0.002, -0.012, -0.011, -0.021, -0.009, 0.002, 0.001, 0.002, 0.005},
			{-0.003, -0.005, -0.034, -0.038, -0.014, 0.012, -0.003, -0.015, -0.019, 0.004, 0.013, 0.007, 0, -0.02, -0.005, -0.002, 0.003, 0.002},
			{-0.006, -0.001, 0.008, -0.004, -0.027, -0.065, -0.043, -0.025, 0.018, 0.052, 0.108, 0.102, 0.059, -0.003, -0.02, -0.022, -0.018, -0.01}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0342, -0.0794, 0.5034, 0.0041, -0.0050, -0.0231},	//FRONT-RIGHT
			{0.0222, -0.0664, 0.5187, -0.0030, -0.0065, 0.0057}  	//FRONT-LEFT
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.073508, 0.04413, 0.00051, 0.00134, 0.00111, 0.00512},	//FRONT-RIGHT
			{0.050656, 0.05078, 0.00996, 0.00041, 0.00020, 0.00217}	//FRONT-LEFT
	};

/*	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = FRONT_L;
	else
		result_ = FRONT_R;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}





int assignDB_BACK_RL ()	{

	int result_;
	printf ("\nassign DB BACK-RightLeft\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{	//BACK-RIGHT
			{-0.016, 0.029, 0.065, 0.011, 0.048, 0.112, 0.277, 0.349, 0.441, 0.403, 0.087, -0.275, -0.428, -0.244, 0.008, 0.11, 0.11, 0.075},
			{0.008, -0.233, -0.462, -0.389, -0.115, 0.236, 0.291, 0.238, 0.06, -0.052, -0.163, -0.267, -0.216, -0.1, 0.037, 0, -0.011, -0.037},
			{0.477, 0.513, 0.574, 0.518, 0.618, 0.632, 0.661, 0.389, 0.37, 0.358, 0.529, 0.537, 0.654, 0.628, 0.563, 0.502, 0.486, 0.5},
			{0.006, 0.006, 0, -0.015, -0.047, -0.038, -0.021, 0.011, -0.002, 0.004, 0.007, -0.012, -0.02, -0.027, 0, 0.002, 0.002, 0},
			{0.001, -0.023, -0.035, -0.016, -0.019, 0.003, 0.016, 0.042, 0.006, -0.033, -0.045, -0.05, -0.033, -0.02, 0.005, 0.003, 0.003, 0.003},
			{-0.003, -0.012, 0.015, 0.041, 0.097, 0.085, 0.057, -0.017, -0.046, -0.08, -0.118, -0.128, -0.098, -0.027, 0, 0.001, -0.006, -0.008}
		},
		{	//BACK-LEFT
			{0.064, 0.07, 0.057, 0.052, 0.061, 0.076, 0.059, 0.025, -0.086, -0.265, -0.379, -0.238, 0.034, 0.271, 0.312, 0.266, 0.164, 0.077},
			{-0.081, -0.164, -0.272, -0.369, -0.344, -0.136, 0.14, 0.388, 0.413, 0.296, -0.026, -0.202, -0.231, -0.117, -0.088, -0.086, -0.078, -0.069},
			{0.509, 0.506, 0.482, 0.5, 0.478, 0.522, 0.497, 0.556, 0.523, 0.517, 0.5, 0.569, 0.48, 0.494, 0.412, 0.509, 0.47, 0.493},
			{-0.001, 0.008, 0.02, 0.035, 0.035, 0.014, -0.016, -0.027, -0.013, 0.001, -0.014, -0.017, -0.033, -0.014, -0.008, 0.007, 0.006, 0.002},
			{0.007, 0.008, 0.018, 0.004, 0.016, 0.033, 0.048, 0.035, -0.004, -0.042, -0.086, -0.044, -0.015, 0.032, 0.005, 0.011, 0.008, 0.001},
			{-0.004, 0.001, 0.008, 0.021, 0.034, 0.036, 0.025, 0, -0.029, -0.045, -0.028, 0.04, 0.091, 0.101, 0.056, 0.016, -0.006, -0.013}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.0646, -0.0653, 0.5283, -0.0080, -0.0107, -0.0137}, //BACK-RIGHT
		{0.0344, -0.0570, 0.5009, -0.0008, 0.0019, 0.0169},  //BACK-LEFT
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.050382, 0.042138, 0.008543, 0.000277, 0.000561, 0.004006},	//BACK-RIGHT
		{0.032978, 0.052047, 0.001137, 0.000363, 0.001049, 0.001517}//BACK-LEFT
	};
/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = BACK_L;
	else
		result_ = BACK_R;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}




int assignDB_RIGHT_FB ()	{

	int result_;
	printf ("\nassign DB RIGHT-frontBack\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0.035, 0.244, 0.425, 0.387, 0.016, -0.348, -0.447, -0.312, -0.133, 0.012, 0.102, 0.11, 0.083, 0.051, 0.068, 0.057, 0.041, 0.019},
			{-0.071, -0.023, 0.003, 0.002, -0.098, -0.158, -0.067, 0.121, 0.285, 0.254, 0.014, -0.286, -0.398, -0.324, -0.162, -0.098, -0.07, -0.07},
			{0.53, 0.541, 0.515, 0.508, 0.487, 0.551, 0.638, 0.687, 0.616, 0.54, 0.416, 0.36, 0.38, 0.432, 0.507, 0.493, 0.515, 0.528},
			{0.002, -0.007, 0.003, 0.01, 0.016, -0.004, -0.017, -0.002, 0.022, 0.044, 0.026, -0.019, -0.042, -0.036, -0.009, -0.005, -0.003, -0.001},
			{0.002, 0.014, 0.013, -0.01, -0.037, -0.043, -0.008, 0.009, 0.016, 0.01, 0.016, 0.023, 0, -0.007, -0.019, -0.005, -0.004, 0},
			{0.007, 0.012, -0.022, -0.058, -0.103, -0.078, -0.036, 0.02, 0.04, 0.034, 0.007, -0.019, -0.027, -0.013, 0, 0.001, -0.004, -0.004}
		},
		{
			{0.053, 0.168, 0.353, 0.446, 0.245, -0.164, -0.457, -0.397, -0.147, 0.046, 0.112, 0.107, 0.122, 0.097, 0.069, 0.009, -0.001, 0.007},
			{-0.005, -0.022, 0.024, 0.085, 0.025, -0.108, -0.259, -0.326, -0.396, -0.389, -0.177, 0.115, 0.384, 0.373, 0.233, 0.02, -0.052, -0.064},
			{0.523, 0.525, 0.546, 0.539, 0.546, 0.471, 0.442, 0.411, 0.457, 0.456, 0.523, 0.521, 0.568, 0.544, 0.574, 0.551, 0.519, 0.503},
			{0.001, 0.002, 0.007, 0.013, -0.004, -0.017, -0.024, -0.007, -0.012, -0.025, -0.028, -0.021, 0.003, 0.014, 0.019, 0.001, -0.011, -0.01},
			{-0.007, -0.015, -0.025, -0.023, 0.007, 0.049, 0.05, 0.013, -0.037, -0.058, -0.033, 0.008, 0.045, 0.029, 0.006, -0.009, -0.004, -0.01},
			{0.004, 0.001, -0.015, -0.061, -0.11, -0.124, -0.07, 0.011, 0.077, 0.092, 0.075, 0.04, 0.014, -0.009, -0.021, -0.022, -0.012, -0.008}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.0228, -0.0637, 0.5136, -0.0012, -0.0017, -0.0135}, //RIGHT-front
		{0.0371, -0.0299, 0.5122, -0.0055, -0.0008, -0.0077} 	//RIGHT-back
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.050592418, 0.030769412, 0.006952261, 0.000431359, 0.000316118, 0.001367441},	//RIGHT-front
		{0.050591163, 0.051681232, 0.002125324, 0.000199441, 0.000913, 0.00343706}	//RIGHT-back
	};

/*	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = RIGHT_F;
	else
		result_ = RIGHT_B;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}





int assignDB_LEFT_FB ()	{

	int result_;
	printf ("\nassign DB LEFT-frontBack\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
				-0.045, -0.28, -0.496, -0.287, 0.18, 0.546, 0.413, 0.158, 0, -0.035, 0.035, 0.096, 0.083, -0.005, -0.073, -0.071, -0.023, -0.005,
				0.032, 0.051, -0.168, -0.284, -0.229, -0.009, 0.133, 0.06, 0.205, 0.427, 0.409, 0.033, -0.432, -0.446, -0.254, -0.05, 0, 0.021,
				0.505, 0.404, 0.434, 0.487, 0.564, 0.542, 0.52, 0.56, 0.628, 0.552, 0.467, 0.466, 0.52, 0.571, 0.49, 0.483, 0.511, 0.514,
				-0.014, -0.013, -0.005, 0.005, 0.002, -0.005, -0.01, -0.009, -0.007, 0.016, 0.032, 0.014, -0.027, -0.033, -0.007, 0.019, 0.012, 0.006,
				0.014, 0.016, -0.023, -0.024, -0.006, 0.022, 0.016, -0.002, 0.013, 0.022, -0.011, -0.01, -0.002, 0.022, 0.01, -0.02, -0.014, -0.011,
				0.012, -0.006, 0.026, 0.102, 0.149, 0.126, 0.029, -0.011, -0.002, 0.003, -0.035, -0.095, -0.09, -0.038, 0.009, 0.018, 0.017, 0.012

		},
		{
			{-0.032, -0.108, -0.303, -0.415, -0.231, 0.111, 0.384, 0.338, 0.212, 0.097, 0.037, 0.003, -0.047, -0.034, -0.023, -0.016, -0.049, -0.048},
			{-0.022, 0.01, -0.043, -0.14, -0.128, -0.061, 0.049, -0.016, -0.114, -0.234, -0.325, -0.223, -0.029, 0.228, 0.291, 0.211, 0.062, -0.014},
			{0.512, 0.502, 0.521, 0.568, 0.571, 0.515, 0.502, 0.488, 0.535, 0.514, 0.521, 0.485, 0.509, 0.455, 0.49, 0.477, 0.549, 0.55},
			{-0.004, 0.001, -0.001, -0.001, -0.005, -0.011, -0.006, -0.001, 0.008, 0.016, 0.022, 0.019, -0.002, -0.004, 0.002, 0.004, -0.006, -0.012},
			{0.002, 0, -0.003, 0, 0.016, 0.016, 0.003, -0.019, -0.023, -0.022, -0.019, 0.002, 0.032, 0.049, 0.023, 0.002, -0.015, -0.006},
			{-0.008, -0.012, 0, 0.044, 0.095, 0.109, 0.072, 0.019, -0.014, -0.028, -0.029, -0.026, -0.014, -0.001, -0.003, -0.008, -0.013, -0.002}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			0.01061, -0.02783, 0.51211, -0.00133, 0.00067, 0.01256,
		{-0.0069, -0.0277, 0.5147, 0.0011, 0.0021, 0.0101}
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			0.05661, 0.05989, 0.00285, 0.00027, 0.00027, 0.00401,
		{0.039284, 0.025894, 0.000969, 0.000092, 0.000377, 0.001748}
	};
/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = LEFT_F;
	else
		result_ = LEFT_B;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}




int assignDB_UP_RL ()	{

	int result_;
	printf ("\nassign DB UP-RightLeft\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0.01, 0.009, 0.023, 0.005, -0.021, -0.038, 0.005, 0.092, 0.178, 0.255, 0.294, 0.265, 0.117, -0.102, -0.238, -0.246, -0.152, -0.083},
			{-0.035, -0.034, -0.016, -0.039, -0.1, -0.138, -0.092, 0.005, 0.045, 0.039, 0.002, -0.016, -0.04, -0.047, -0.01, 0.028, 0.072, 0.078},
			{0.519, 0.591, 0.758, 0.834, 0.747, 0.473, 0.232, 0.131, 0.225, 0.383, 0.501, 0.534, 0.539, 0.515, 0.509, 0.501, 0.499, 0.484},
			{-0.011, -0.014, 0, 0.024, 0.045, 0.05, 0.029, 0.009, -0.014, -0.014, -0.003, 0.016, 0.034, 0.027, 0.013, -0.001, -0.003, -0.006},
			{0, -0.003, -0.003, 0.002, 0.011, 0.023, 0.018, 0.001, -0.026, -0.037, -0.036, -0.026, -0.011, 0.004, 0.014, 0.011, 0.01, 0.006},
			{-0.001, 0.003, 0.005, 0.007, 0.001, 0.005, 0.016, 0.012, -0.003, -0.029, -0.042, -0.06, -0.076, -0.087, -0.073, -0.045, -0.018, -0.004}
		},
		{
			{-0.009, -0.002, 0.022, 0.042, 0.047, 0.025, 0.03, 0.014, -0.021, -0.119, -0.26, -0.36, -0.243, 0.045, 0.329, 0.391, 0.292, 0.175},
			{-0.025, -0.012, -0.05, -0.083, -0.066, -0.036, 0.017, 0.007, 0.026, 0.026, 0.003, -0.012, -0.017, -0.047, -0.122, -0.134, -0.088, 0.002},
			{0.554, 0.716, 0.873, 0.888, 0.52, 0.161, 0.018, 0.203, 0.437, 0.568, 0.605, 0.539, 0.484, 0.375, 0.47, 0.483, 0.555, 0.482},
			{-0.008, -0.022, -0.012, 0.046, 0.084, 0.077, 0.016, -0.01, -0.024, -0.016, -0.012, -0.008, -0.027, -0.045, -0.04, -0.011, 0.008, 0.012},
			{-0.002, -0.015, -0.035, -0.024, 0.022, 0.042, 0.029, -0.014, -0.017, -0.019, -0.017, -0.007, 0.002, -0.003, -0.026, -0.02, -0.004, 0.01},
			{0.001, 0.014, 0.015, 0.006, -0.003, -0.006, 0.001, -0.009, -0.007, -0.009, 0.012, 0.043, 0.075, 0.072, 0.053, 0.027, 0.018, 0.003}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.02072, -0.01656, 0.49861, 0.01006, -0.00233, -0.02161},
		{0.02211, -0.03394, 0.49617, 0.00044, -0.00544, 0.01700}
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.02518, 0.00332, 0.03229, 0.00043, 0.00032, 0.00114},
		{0.03808, 0.00235, 0.04802, 0.00129, 0.00041, 0.00072}
	};

/*	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = UP_R;
	else
		result_ = UP_L;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}


int assignDB_DOWN_RL ()	{

	int result_;
	printf ("\nassign DB DOWN-RightLeft\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0, -0.008, -0.016, -0.015, 0.013, 0.086, 0.2, 0.316, 0.371, 0.303, 0.123, -0.143, -0.306, -0.33, -0.217, -0.112, -0.049, -0.024},
			{0.034, -0.001, -0.021, 0.002, -0.006, -0.05, -0.109, -0.077, -0.014, 0.004, 0.006, -0.068, -0.072, -0.07, -0.009, 0.009, 0.012, 0.022},
			{0.487, 0.412, 0.241, 0.08, 0.2, 0.528, 0.883, 0.907, 0.73, 0.529, 0.434, 0.42, 0.476, 0.478, 0.506, 0.482, 0.497, 0.502},
			{-0.001, 0.007, 0.005, -0.023, -0.064, -0.079, -0.053, 0.003, 0.044, 0.068, 0.044, 0.013, -0.012, -0.015, -0.006, 0, 0.001, 0.002},
			{0.013, 0.004, 0.035, 0, -0.032, -0.086, -0.034, 0.019, 0.051, 0.015, 0.007, -0.003, 0.014, 0.013, 0.014, 0.006, 0, -0.001},
			{0.011, 0.013, 0.021, 0.017, 0.012, 0.001, 0.003, -0.004, -0.025, -0.051, -0.085, -0.1, -0.084, -0.044, -0.007, 0.005, 0.01, 0.007}
		},
		{
			{-0.018, -0.033, -0.067, -0.049, 0.018, 0.069, 0.064, -0.024, -0.135, -0.274, -0.315, -0.115, 0.153, 0.349, 0.306, 0.184, 0.071, 0.02},
			{-0.012, -0.047, -0.036, -0.048, -0.046, -0.104, -0.19, -0.202, -0.218, -0.19, -0.187, -0.159, -0.096, -0.081, -0.055, -0.087, -0.125, -0.16},
			{0.485, 0.426, 0.235, -0.025, 0.036, 0.39, 0.833, 0.905, 0.778, 0.569, 0.508, 0.466, 0.451, 0.418, 0.424, 0.457, 0.496, 0.504},
			{0.001, 0.003, 0.011, -0.022, -0.075, -0.12, -0.091, -0.037, 0.009, 0.019, 0.029, 0.025, 0.033, 0.024, 0.009, -0.011, -0.021, -0.009},
			{0.015, 0.02, 0.033, 0.017, -0.02, -0.078, -0.058, -0.018, 0.018, 0.002, -0.02, -0.003, 0, -0.006, -0.011, -0.017, -0.005, -0.018},
			{0.001, 0.005, -0.004, -0.004, -0.006, -0.01, -0.02, -0.025, -0.007, 0.019, 0.053, 0.076, 0.057, 0.037, 0.004, 0, -0.012, -0.006}

		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.01067, -0.02267, 0.48844, -0.00367, 0.00194, -0.01667},
		{0.01133, -0.11350, 0.46422, -0.01239, -0.00828, 0.00878}
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.03977, 0.00167, 0.04224, 0.00133, 0.00087, 0.00152},
		{0.02939, 0.00443, 0.05476, 0.00187, 0.00073, 0.00080}

	};
/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = DOWN_R;
	else
		result_ = DOWN_L;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}


int assignDB_RIGHT_UD ()	{

	int result_;
	printf ("\nassign DB RIGHT-UpDown\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0.01, 0.08, 0.28, 0.374, 0.148, -0.248, -0.422, -0.242, -0.035, 0.04, 0.016, 0.019, 0.023, 0.043, 0.031, 0.018, 0.009, 0.015},
			{-0.057, -0.084, -0.064, -0.062, -0.112, -0.214, -0.233, -0.21, -0.145, -0.143, -0.136, -0.019, 0.028, 0.116, 0.069, 0.069, 0.048, 0.035},
			{0.524, 0.512, 0.578, 0.558, 0.44, 0.427, 0.537, 0.825, 0.863, 0.791, 0.584, 0.295, 0.178, 0.134, 0.263, 0.341, 0.437, 0.519},
			{-0.008, -0.009, -0.009, 0.007, 0.014, 0.001, -0.013, -0.019, 0.018, 0.062, 0.096, 0.097, 0.058, 0.025, -0.007, -0.016, -0.02, -0.016},
			{0.004, 0.008, 0.015, 0.032, 0.014, -0.025, -0.052, -0.037, -0.01, -0.022, -0.01, 0.02, 0.03, 0.027, 0.001, 0, -0.011, -0.01},
			{0.008, 0.011, -0.004, -0.053, -0.114, -0.119, -0.062, 0.012, 0.036, 0.016, 0.008, 0.011, 0.015, 0.001, -0.01, -0.013, -0.012, -0.008}
		},
		{
			{0.011, 0.109, 0.278, 0.387, 0.342, 0.106, -0.187, -0.339, -0.279, -0.129, 0.017, 0.09, 0.144, 0.11, 0.079, 0.069, 0.073, 0.061},
			{0, -0.004, -0.02, 0.035, 0.068, 0.079, -0.031, -0.107, -0.147, -0.104, -0.044, -0.068, -0.063, -0.089, -0.059, -0.071, -0.102, -0.108},
			{0.52, 0.516, 0.542, 0.56, 0.556, 0.508, 0.488, 0.486, 0.427, 0.229, 0.176, 0.415, 0.733, 0.828, 0.679, 0.571, 0.518, 0.494},
			{0.008, 0.007, 0.002, -0.002, 0.012, 0.014, -0.004, -0.02, -0.024, -0.024, -0.059, -0.086, -0.069, -0.034, -0.006, -0.005, 0.003, 0.006},
			{0, -0.005, -0.005, -0.014, -0.023, -0.032, -0.032, -0.019, -0.005, 0.014, 0, -0.019, -0.022, 0.007, 0.016, 0.009, -0.003, 0.003},
			{-0.005, -0.003, -0.011, -0.035, -0.076, -0.114, -0.118, -0.081, -0.021, 0.018, 0.031, 0.032, 0.023, 0.016, 0.005, 0.001, -0.003, -0.002}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.00883, -0.06189, 0.48922, 0.01450, -0.00144, -0.01539},
		{0.05233, -0.04639, 0.51367, -0.01561, -0.00722, -0.01906}
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.03240, 0.01139, 0.04194, 0.00147, 0.00054, 0.00190},
		{0.03668, 0.00398, 0.02332, 0.00086, 0.00022, 0.00222}
	};

/*	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = RIGHT_U;
	else
		result_ = RIGHT_D;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}


int assignDB_LEFT_UD ()	{

	int result_;
	printf ("\nassign DB Left-UpDown\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
				0.001, -0.073, -0.286, -0.4, -0.255, 0.11, 0.353, 0.328, 0.203, 0.11, 0.087, 0.064, 0.046, 0.013, 0.004, 0, 0.02, 0.035,
				0.001, -0.001, -0.082, -0.146, -0.148, -0.043, 0.013, -0.032, -0.087, -0.101, 0.008, 0.061, 0.105, 0.051, 0.054, 0.047, 0.098, 0.094,
				0.501, 0.523, 0.479, 0.449, 0.478, 0.492, 0.551, 0.666, 0.865, 0.897, 0.605, 0.274, 0.086, 0.132, 0.278, 0.403, 0.504, 0.535,
				-0.002, -0.005, -0.005, -0.003, 0.001, -0.003, -0.012, -0.008, 0.029, 0.085, 0.096, 0.072, 0.019, 0.002, -0.008, -0.009, -0.011, -0.01,
				0.002, 0.005, 0.014, -0.005, -0.011, -0.019, -0.018, -0.031, -0.037, -0.01, 0.025, 0.028, 0.022, -0.002, -0.011, -0.017, -0.012, -0.006,
				-0.004, -0.012, -0.006, 0.03, 0.061, 0.068, 0.036, 0.007, -0.004, -0.001, 0.004, -0.003, -0.013, -0.018, -0.01, -0.001, 0.006, 0.005
		},
		{
			{-0.044, -0.19, -0.395, -0.417, -0.171, 0.189, 0.385, 0.375, 0.244, 0.025, -0.05, -0.06, 0.018, 0.01, -0.016, -0.008, -0.009, 0.012},
			{0.001, -0.034, -0.144, -0.205, -0.161, -0.005, 0.066, 0.064, -0.015, -0.104, -0.013, -0.047, -0.04, -0.204, -0.222, -0.201, -0.174, -0.133},
			{0.517, 0.504, 0.482, 0.492, 0.478, 0.47, 0.493, 0.515, 0.416, 0.084, 0.003, 0.29, 0.73, 0.927, 0.788, 0.656, 0.523, 0.482},
			{0, 0.004, 0.008, 0.002, -0.005, -0.022, -0.02, -0.003, 0.029, 0.06, -0.03, -0.091, -0.134, -0.061, -0.011, 0.009, 0.018, 0.011},
			{0.007, 0.011, 0.003, 0.003, -0.007, -0.011, -0.013, 0.001, 0.033, 0.031, 0.004, -0.044, -0.042, -0.033, -0.008, -0.005, 0.004, 0.005},
			{-0.01, -0.018, 0.006, 0.062, 0.112, 0.099, 0.049, -0.009, -0.038, -0.043, -0.016, -0.001, 0.002, -0.011, -0.009, -0.006, -0.001, 0.001}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			0.02000, -0.00600, 0.48433, 0.01267, -0.00461, 0.00806,
			0.00444, -0.01417, 0.50989, 0.00411, 0.00528, 0.00128,
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			0.03636, 0.00653, 0.04409, 0.00121, 0.00033, 0.00061,
		{0.03139, 0.00457, 0.03045, 0.00029, 0.00043, 0.00170}
	};

/*	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = LEFT_U;
	else
		result_ = LEFT_D;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}







int assignDB_UP_FB ()	{

	int result_;
	printf ("\nassign DB UP-FrontBack\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{-0.015, -0.023, -0.033, -0.035, -0.05, -0.057, -0.043, -0.02, -0.001, -0.007, 0.01, 0.069, 0.117, 0.121, 0.054, 0.007, -0.003, 0.012},
			{-0.019, -0.021, -0.056, -0.068, -0.093, -0.05, -0.008, 0.113, 0.197, 0.28, 0.27, 0.179, -0.016, -0.207, -0.289, -0.242, -0.148, -0.082},
			{0.575, 0.679, 0.779, 0.785, 0.599, 0.348, 0.189, 0.207, 0.345, 0.431, 0.484, 0.481, 0.504, 0.532, 0.55, 0.531, 0.538, 0.542},
			{-0.035, -0.03, 0.004, 0.034, 0.056, 0.044, 0.021, -0.008, -0.018, -0.007, 0.01, 0.012, -0.013, -0.044, -0.044, -0.018, 0.007, 0.012},
			{0.005, 0.003, -0.003, 0.004, 0.017, 0.017, 0.002, -0.014, -0.022, -0.025, -0.033, -0.035, -0.014, 0.01, 0.027, 0.015, 0.006, 0.008},
			{0.007, 0.005, 0.011, 0.013, 0.017, 0.013, 0.016, 0.017, 0.011, 0, -0.016, -0.015, -0.029, -0.033, -0.04, -0.024, -0.007, 0.002}
		},
		{
			{0.026, 0.024, 0.01, 0.002, 0.017, 0, -0.017, -0.028, 0.018, 0.05, 0.071, 0.076, 0.067, 0.004, -0.068, -0.092, -0.057, -0.023},
			{-0.019, 0, 0, -0.007, -0.008, -0.023, -0.054, -0.083, -0.12, -0.212, -0.357, -0.349, -0.152, 0.154, 0.33, 0.324, 0.216, 0.105},
			{0.566, 0.649, 0.744, 0.784, 0.752, 0.503, 0.273, 0.174, 0.299, 0.449, 0.53, 0.541, 0.478, 0.449, 0.444, 0.492, 0.522, 0.529},
			{-0.004, -0.017, -0.006, 0.017, 0.036, 0.02, 0, -0.014, -0.013, -0.015, -0.003, 0.007, 0.015, 0.019, 0.016, 0.009, 0.004, 0.003},
			{0.001, 0.015, 0.015, 0.008, 0.013, 0.013, 0.008, -0.013, -0.017, -0.014, -0.002, 0.013, 0.019, 0.017, 0.006, 0.007, 0.003, 0.003},
			{-0.003, 0.002, 0.008, 0.012, 0.016, 0.011, 0.006, 0.003, 0.001, 0.004, 0.009, 0.025, 0.015, -0.006, -0.032, -0.027, -0.015, -0.006}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		0.05144, -0.03989, 0.50944, -0.00233, -0.00500, 0.00106,
		-0.01233, -0.05317, 0.51672, -0.01233, 0.01322, -0.00661
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		0.00276, 0.02734, 0.02640, 0.00083, 0.00033, 0.00035,
		0.00220, 0.03730, 0.02585, 0.00021, 0.00012, 0.00021
	};
/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = UP_B;
	else
		result_ = UP_F;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}


int assignDB_DOWN_FB ()	{

	int result_;
	printf ("\nassign DB DOWN-FrontBack\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{-0.006, -0.007, -0.034, -0.039, 0.025, 0.116, 0.163, 0.12, 0.057, 0.003, -0.067, -0.001, 0.143, 0.216, 0.131, 0.021, 0.026, 0.059},
			{0.021, 0.002, -0.026, -0.063, -0.068, -0.033, -0.008, -0.005, -0.019, 0.069, 0.297, 0.509, 0.175, -0.316, -0.646, -0.421, -0.15, -0.036},
			{0.509, 0.427, 0.197, 0.011, 0.242, 0.633, 0.952, 0.842, 0.675, 0.589, 0.549, 0.402, 0.497, 0.604, 0.656, 0.519, 0.392, 0.474},
			{0.004, 0.018, 0.044, 0.021, -0.023, -0.072, -0.068, -0.04, -0.013, -0.001, 0.042, 0.076, 0.055, -0.012, -0.049, -0.028, 0.003, 0.001},
			{0.003, 0.017, 0.02, -0.013, -0.061, -0.06, -0.026, 0.027, 0.025, 0.023, 0.005, -0.001, -0.045, -0.008, -0.004, 0.023, -0.01, -0.005},
			{-0.002, 0.001, 0.005, 0.012, 0.025, 0.028, 0.018, 0.003, -0.003, 0.008, 0.012, 0.003, -0.016, -0.051, -0.034, -0.016, 0.018, 0.008}
		},
		{
			{-0.022, -0.045, -0.074, -0.032, 0.061, 0.134, 0.127, 0.067, 0.04, 0.017, 0.008, -0.007, -0.052, -0.077, -0.102, -0.088, -0.091, -0.086},
			{-0.018, -0.026, -0.055, -0.041, -0.044, -0.05, -0.078, -0.117, -0.181, -0.308, -0.338, -0.201, 0.144, 0.275, 0.249, 0.017, -0.073, -0.112},
			{0.464, 0.335, 0.182, 0.206, 0.478, 0.798, 0.883, 0.746, 0.568, 0.449, 0.431, 0.481, 0.56, 0.563, 0.556, 0.536, 0.553, 0.512},
			{0.009, 0.024, 0.003, -0.034, -0.071, -0.061, -0.031, -0.002, 0.017, 0.027, 0.029, 0, -0.026, -0.048, -0.033, -0.021, -0.004, 0},
			{-0.003, -0.003, -0.008, -0.022, -0.037, -0.026, 0.004, 0.025, 0.02, 0.015, 0.006, 0.036, 0.067, 0.081, 0.061, 0.02, 0.007, -0.005},
			{-0.002, 0, 0.012, 0.021, 0.017, 0.003, -0.011, -0.015, -0.017, -0.021, -0.017, -0.006, -0.001, -0.01, -0.026, -0.028, -0.015, -0.003}

		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		0.01661, -0.00856, 0.47361, 0.00439, -0.00911, -0.00078,
		0.00483, -0.07300, 0.50317, -0.01317, -0.00361, 0.00089
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		0.00628, 0.06374, 0.04933, 0.00168, 0.00077, 0.00040,
		0.00547, 0.02575, 0.03146, 0.00089, 0.00102, 0.00019
	};

/*	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = DOWN_B;
	else
		result_ = DOWN_F;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}


int assignDB_FRONT_UD ()	{

	int result_;
	printf ("\nassign DB FRONT-UpDown\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{-0.011, -0.025, -0.026, -0.01, 0.046, 0.027, -0.026, -0.065, 0.008, 0.057, 0.055, -0.01, -0.009, 0.019, 0.056, 0.07, 0.073, 0.07},
			{0.001, 0.157, 0.339, 0.439, 0.245, -0.111, -0.407, -0.385, -0.253, -0.185, -0.179, -0.113, 0.02, 0.079, 0.073, 0.065, 0.034, 0.027},
			{0.513, 0.499, 0.532, 0.53, 0.488, 0.454, 0.517, 0.717, 0.882, 0.962, 0.675, 0.248, -0.02, -0.015, 0.21, 0.336, 0.477, 0.52},
			{-0.007, -0.008, 0.004, 0.027, 0.039, -0.005, -0.047, -0.072, -0.029, 0.038, 0.089, 0.086, 0.027, -0.008, -0.023, -0.012, -0.012, -0.008},
			{0.002, 0.012, -0.011, -0.018, -0.018, 0.019, 0.016, -0.006, -0.056, -0.052, -0.012, 0.018, 0.017, -0.017, -0.023, -0.023, -0.011, -0.001},
			{0.015, 0.014, 0.01, 0.001, -0.017, -0.026, -0.016, 0.009, 0.018, 0.007, 0.003, 0, 0.005, -0.012, -0.011, -0.013, -0.002, 0.001}
		},
		{
			{-0.051, -0.078, -0.088, -0.05, -0.005, 0.014, -0.016, -0.008, 0.008, 0.05, 0.063, 0.102, 0.079, 0.045, -0.011, -0.002, 0.013, 0.022},
			{0.007, 0.101, 0.219, 0.319, 0.201, -0.1, -0.386, -0.479, -0.32, -0.092, 0.045, 0.042, -0.117, -0.208, -0.226, -0.15, -0.091, -0.079},
			{0.502, 0.508, 0.487, 0.523, 0.472, 0.501, 0.474, 0.485, 0.357, 0.233, 0.184, 0.467, 0.705, 0.85, 0.693, 0.587, 0.522, 0.507},
			{-0.001, -0.004, 0, 0, 0.005, -0.005, -0.026, -0.025, -0.013, 0.013, -0.028, -0.067, -0.085, -0.037, 0.003, 0.017, 0.01, 0.006},
			{0.002, 0.001, -0.004, -0.009, -0.006, -0.019, -0.019, -0.021, 0.009, 0.006, -0.021, -0.042, -0.014, 0.024, 0.037, 0.009, 0.001, 0.001},
			{-0.001, 0.004, 0.008, 0.01, 0.008, -0.008, -0.009, -0.003, 0.02, 0.03, 0.026, 0.001, -0.018, -0.028, -0.016, -0.006, -0.001, -0.001}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		0.01050, 0.00589, 0.47394, 0.01111, -0.00239, -0.00056,
		-0.00394, -0.05089, 0.51444, -0.00994, 0.00078, -0.00611
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		0.00173, 0.05167, 0.06707, 0.00169, 0.00048, 0.00016,
		0.00265, 0.04427, 0.02381, 0.00076, 0.00033, 0.00022
	};

	/*if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = FRONT_D;
	else
		result_ = FRONT_U;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}


int assignDB_BACK_UD ()	{

	int result_;
	printf ("\nassign DB Back-UpDown\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0, 0.017, 0.041, 0.063, 0.026, 0.011, -0.01, -0.004, -0.049, -0.039, -0.053, -0.029, -0.007, 0.055, 0.084, 0.051, 0.02, 0.012},
			{-0.087, -0.184, -0.304, -0.303, -0.177, 0.106, 0.324, 0.358, 0.187, -0.001, -0.079, -0.045, 0.074, 0.095, 0.094, 0.003, 0.011, 0.034},
			{0.518, 0.538, 0.487, 0.527, 0.421, 0.453, 0.394, 0.573, 0.757, 0.925, 0.799, 0.499, 0.211, 0.16, 0.208, 0.287, 0.347, 0.427},
			{0.01, 0.02, 0.029, 0.032, 0.023, -0.013, -0.041, -0.059, -0.042, -0.016, 0.031, 0.068, 0.079, 0.056, 0.029, 0.008, -0.003, -0.011},
			{-0.011, -0.01, -0.003, 0.006, 0.017, 0.007, 0.028, 0.01, 0.013, -0.007, -0.025, -0.029, -0.041, -0.028, -0.008, 0.004, 0.02, 0.014},
			{-0.003, -0.003, 0.008, 0.012, 0.024, 0.006, -0.011, -0.031, -0.022, 0.009, 0.029, 0.03, 0.009, -0.012, -0.02, -0.019, -0.01, -0.006}
		},
		{
			-0.021, -0.034, -0.008, 0.056, 0.08, 0.05, -0.006, -0.014, -0.02, -0.026, 0.001, 0.076, 0.06, 0.007, -0.053, 0.005, 0.046, 0.053,
			-0.063, -0.148, -0.309, -0.365, -0.309, -0.018, 0.246, 0.427, 0.387, 0.256, 0.081, -0.111, -0.267, -0.33, -0.29, -0.217, -0.159, -0.12,
			0.503, 0.508, 0.523, 0.561, 0.521, 0.493, 0.406, 0.425, 0.337, 0.203, 0.008, 0.272, 0.623, 0.953, 0.829, 0.711, 0.554, 0.47,
			0, 0.006, 0.006, 0.001, -0.003, -0.007, -0.017, -0.009, -0.005, 0.007, -0.025, -0.105, -0.103, -0.066, 0.017, 0.012, 0.005, 0.002,
			-0.002, -0.014, -0.026, 0.006, 0.037, 0.056, 0.026, 0.004, -0.006, -0.011, -0.014, -0.009, -0.027, -0.025, -0.032, 0.001, 0.017, 0.023,
			0, -0.004, -0.008, -0.009, 0.02, 0.041, 0.058, 0.031, 0.003, -0.029, -0.048, -0.05, -0.042, -0.024, -0.008, 0.004, 0.008, 0.002

		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		0.01050, 0.00589, 0.47394, 0.01111, -0.00239, -0.00056,
		0.01400, -0.07272, 0.49444, -0.01578, 0.00022, -0.00306
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		0.00151, 0.03345, 0.04177, 0.00141, 0.00037, 0.00031,
		0.00169, 0.06372, 0.04732, 0.00136, 0.00057, 0.00086
	};
/*
	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = BACK_D;
	else
		result_ = BACK_U;

	return result_;
		*/
	return (result_ = crossCorrelation(db_sample, db_average, db_cov));
}




/*
struct minMax	{
	int min_;
	int max_;
	int min_seq;
	int max_seq;
	int gap_;
	int maxFlag;
	int minFlag;

};

*/


unsigned char gestureRecognition (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{

	//struct minMax mm [AXIS_NUM];


	int min_ [AXIS_NUM] = {10000,10000,30000,10000,10000,10000};
	int max_ [AXIS_NUM] = {-10000, -10000,-1000,-1000,-1000,-1000};

	int min_seq [AXIS_NUM]= {-1,-1,-1,-1,-1,-1};
	int max_seq [AXIS_NUM]= {-1,-1,-1,-1,-1,-1};

	int gaps [AXIS_NUM] = {0,0,0,0,0,0};
	int maxFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	int minFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	unsigned char Motionflag_ = 0;
	int nLoop, nLoop2;
	int result_ = 0 ;

	memset (biggestValue, 0, sizeof (biggestValue));
	memset (WEIGHTED_AXIS, 2, sizeof (WEIGHTED_AXIS));

	normalizingFunction (sensor);

	//	printf ("<INPUT>\n");
	/*for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			printf ("%d,", sensor [nLoop][nLoop2] );
		}
		printf ("\n");
	}
	//printf ("\n");
*/

#ifdef WMA_FACTOR
	weightedMovingAverage (sensor);
#endif


	//	printf ("<INPUT>\n");
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM; nLoop2 ++)	{
			printf ("%d\t", WMA_SENSOR [nLoop][nLoop2] );
		}
		printf ("\n");
	}
	printf ("\n");



	char temp_flag = 0;

	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{

		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM; nLoop2 ++)	{

			if (min_[nLoop] > WMA_SENSOR [nLoop][nLoop2])	{
				min_[nLoop] = WMA_SENSOR [nLoop][nLoop2];
				minFlag [nLoop] |= 0x1;
				min_seq [nLoop] = nLoop2;

			} else if (max_[nLoop] < WMA_SENSOR [nLoop][nLoop2])	{
				max_[nLoop] = WMA_SENSOR [nLoop][nLoop2];
				maxFlag [nLoop] |= 0x1;
				max_seq [nLoop] = nLoop2;
			}
			minFlag[nLoop] = minFlag[nLoop] << 1;
			maxFlag[nLoop] = maxFlag[nLoop] << 1;

		}

		if (min_seq [nLoop] > max_seq [nLoop]){
			int tempInt = min_seq [nLoop];
			min_seq [nLoop] = max_seq [nLoop];
			max_seq [nLoop] = tempInt;
		}
		printf ("%d: %d & %d\n", nLoop, min_seq [nLoop],max_seq [nLoop]);

		gaps [nLoop] = max_ [nLoop] - min_ [nLoop];
		//printf ("%d: %d /  ", nLoop, gaps [nLoop]);

		if (gaps [nLoop] > 400)	{
			Motionflag_ |= 0x1;
			temp_flag ++;
			WEIGHTED_AXIS [nLoop] = 90;
		}
		Motionflag_ = Motionflag_ << 1;

	} //for

	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{
		WEIGHTED_AXIS [nLoop] /= temp_flag;
	}


//	printf ("1. motionflag: %x\n", Motionflag_ & 0xff);

	if (!Motionflag_ )	{
		result_ = NONE;
	//else if (Motionflag_ == 32)
	}
	else {

		int temp_result [NUM_OF_DB], max=0, max_gest=0;
		memset (temp_result, 0, sizeof(temp_result));

		if ((Motionflag_ & 0x70) == 0x70)	{	//find two axis that have biggest gap
			int temp_max_flag = gaps [0] > gaps [1] ? 1 : 0;

			if (gaps [temp_max_flag] > gaps [2])	{
				Motionflag_ &= 0x6F;
			}
			else if (temp_max_flag)	{
				Motionflag_ &= 0x5F;
			}
			else
				Motionflag_ &= 0x3F;
		}
		//printf ("2. motionflag: %x\n", Motionflag_ & 0xff);

		switch (Motionflag_ & 0x70)	{
		case 0x20:	//FRONT
			result_ = assignDB_FRONT ();
			break;
		case 0x40:		//SIDE
			result_ = assignDB_RIGHT ();
			break;
		case 0x10:	//UP
			result_ = assignDB_UP ();
			break;
		case 0x50:

			if (((max_seq [ACC_X] - min_seq [ACC_Z] > CIRCLE_THRESH ) && (min_seq [ACC_X] <= min_seq [ACC_Z] ))
					|| ((max_seq [ACC_Z] - min_seq [ACC_X] > CIRCLE_THRESH ) && (min_seq [ACC_Z] <= min_seq [ACC_X] )))	{

				/*result_ = CLOCK;
				deriveCorrelation ();
				result_ = compareSelfCorrleation (CLOCK);
				*/
				temp_result [0] = assignDB_CLOCK ();
				biggestValue [CLOCK] = biggestValue [0];
				biggestValue [ANTI_CLOCK] = biggestValue [1];

				WEIGHTED_AXIS [0] = 90;
				WEIGHTED_AXIS [1] = WEIGHTED_AXIS [2] = 1;
				temp_result [1] = assignDB_RIGHT ();
				biggestValue [RIGHT] = biggestValue [0];
				biggestValue [LEFT] = biggestValue [1];

				WEIGHTED_AXIS [2] = 90;
				WEIGHTED_AXIS [1] = WEIGHTED_AXIS [0] = 1;
				temp_result [2]= assignDB_UP ();
				biggestValue [UP] = biggestValue [0];
				biggestValue [DOWN] = biggestValue [1];


				if (biggestValue [CLOCK + temp_result [0]] > biggestValue [RIGHT + temp_result [1]])	{
					if (biggestValue [CLOCK + temp_result [0]] < biggestValue [UP + temp_result [2]])	{
						result_ = UP + temp_result [2];
					}
					else 	{
						result_ = CLOCK + temp_result [0];
					}
				}
				else	{
					if (biggestValue [RIGHT + temp_result [1]] < biggestValue [UP + temp_result [2]])	{
						result_ = UP + temp_result [2];
					}
					else 	{
						result_ = RIGHT + temp_result [1];
					}
				}


			}
			else	{

				if (min_seq [ACC_X] >= min_seq [ACC_Z] )	{
					temp_result [1] = assignDB_UP_RL ();
					biggestValue [UP_R] = biggestValue [0];
					biggestValue [UP_L] = biggestValue [1];


					temp_result [2] = assignDB_DOWN_RL ();
					biggestValue [DOWN_R] = biggestValue [0];
					biggestValue [DOWN_L] = biggestValue [1];

					for (nLoop = UP_R; nLoop <= DOWN_L; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				} //if
				else	{

					temp_result [3] = assignDB_RIGHT_UD ();
					biggestValue [RIGHT_U] = biggestValue [0];
					biggestValue [RIGHT_D] = biggestValue [1];

					temp_result [4] = assignDB_LEFT_UD ();
					biggestValue [LEFT_U] = biggestValue [0];
					biggestValue [LEFT_D] = biggestValue [1];

					for (nLoop = RIGHT_U; nLoop <= LEFT_D; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				} //else
			} //else


			break;
		case 0x60:

			if (((max_seq [ACC_X] - min_seq [ACC_Y] > CIRCLE_THRESH ) && (min_seq [ACC_X] <= min_seq [ACC_Y] ))
					|| ((max_seq [ACC_Y] - min_seq [ACC_X] > CIRCLE_THRESH ) && (min_seq [ACC_Y] <= min_seq [ACC_X] )))	{

				result_ = LOW_CLOCK;
				deriveCorrelation ();
				result_ = compareSelfCorrleation (LOW_CLOCK);
			}
			else	{

				if (min_seq [ACC_X] >= min_seq [ACC_Y] )	{

					temp_result [1] = assignDB_FRONT_RL ();
					biggestValue [FRONT_R] = biggestValue [0];
					biggestValue [FRONT_L] = biggestValue [1];

					temp_result [2] = assignDB_BACK_RL ();
					biggestValue [BACK_R] = biggestValue [0];
					biggestValue [BACK_L] = biggestValue [1];

					for (nLoop = FRONT_R; nLoop <= BACK_L; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				} //if
				else	{

					temp_result [3] = assignDB_RIGHT_FB ();
					biggestValue [RIGHT_F] = biggestValue [0];
					biggestValue [RIGHT_B] = biggestValue [1];

					temp_result [4] = assignDB_LEFT_FB ();
					biggestValue [LEFT_F] = biggestValue [0];
					biggestValue [LEFT_B] = biggestValue [1];

					for (nLoop = RIGHT_F; nLoop <= LEFT_B; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for

				} //else
			} //else

			break;
		case 0x30:

			if (((max_seq [ACC_Y] - min_seq [ACC_Z] > CIRCLE_THRESH ) && (min_seq [ACC_Y] <= min_seq [ACC_Z] ))
						|| ((max_seq [ACC_Z] - min_seq [ACC_Y] > CIRCLE_THRESH ) && (min_seq [ACC_Z] <= min_seq [ACC_Y] )))	{

			/*	result_ = SIDE_CLOCK;
				deriveCorrelation ();
				result_ = compareSelfCorrleation (SIDE_CLOCK);
				*/

				temp_result [0] = assignDB_SIDE ();
				biggestValue [SIDE_CLOCK] = biggestValue [0];
				biggestValue [SIDE_ANTI] = biggestValue [1];

				WEIGHTED_AXIS [1] = 90;
				WEIGHTED_AXIS [0] = WEIGHTED_AXIS [2] = 1;
				temp_result [1] = assignDB_FRONT ();
				biggestValue [FRONT] = biggestValue [0];
				biggestValue [BACK] = biggestValue [1];

				WEIGHTED_AXIS [2] = 90;
				WEIGHTED_AXIS [1] = WEIGHTED_AXIS [0] = 1;
				temp_result [2]= assignDB_UP ();
				biggestValue [UP] = biggestValue [0];
				biggestValue [DOWN] = biggestValue [1];


				if (biggestValue [SIDE_CLOCK + temp_result [0]] > biggestValue [FRONT + temp_result [1]])	{
					if (biggestValue [SIDE_CLOCK + temp_result [0]] < biggestValue [UP + temp_result [2]])	{
						result_ = UP + temp_result [2];
					}
					else 	{
						result_ = SIDE_CLOCK + temp_result [0];
					}
				}
				else	{
					if (biggestValue [FRONT + temp_result [1]] < biggestValue [UP + temp_result [2]])	{
						result_ = UP + temp_result [2];
					}
					else 	{
						result_ = FRONT + temp_result [1];
					}
				}

			}
			else	{

				if (min_seq [ACC_Y] >= min_seq [ACC_Z] )	{

					temp_result [1] = assignDB_UP_FB ();
					biggestValue [UP_F] = biggestValue [0];
					biggestValue [UP_B] = biggestValue [1];

					temp_result [2] = assignDB_DOWN_FB ();
					biggestValue [DOWN_F] = biggestValue [0];
					biggestValue [DOWN_B] = biggestValue [1];

					for (nLoop = UP_F; nLoop <= DOWN_B; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				}	//if

				else 	{
					temp_result [3] = assignDB_FRONT_UD ();
					biggestValue [FRONT_U] = biggestValue [0];
					biggestValue [FRONT_D] = biggestValue [1];

					temp_result [4] = assignDB_BACK_UD ();
					biggestValue [BACK_U] = biggestValue [0];
					biggestValue [BACK_D] = biggestValue [1];

					for (nLoop = FRONT_U; nLoop <= BACK_D; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				} //else

			} //else

			break;
		default:

			temp_result [0] = assignDB_CLOCK ();
			biggestValue [CLOCK] = biggestValue [0];
			biggestValue [ANTI_CLOCK] = biggestValue [1];

			temp_result [1] = assignDB_LOW ();
			biggestValue [LOW_CLOCK] = biggestValue [0];
			biggestValue [LOW_ANTI] = biggestValue [1];

			temp_result [2] = assignDB_SIDE ();
			biggestValue [SIDE_CLOCK] = biggestValue [0];
			biggestValue [SIDE_ANTI] = biggestValue [1];

		//	printf ("\n%d %d %d\n", temp_result[0], temp_result[1], temp_result[2]);
		//	printf ("%d %d %d\n", biggestValue[temp_result[0]], biggestValue[temp_result[1]], biggestValue[temp_result[2]]);

			for (nLoop = 0; nLoop < 3; nLoop ++)	{
				if (max < biggestValue [temp_result[nLoop]])	{
					max = biggestValue [temp_result[nLoop]];
					result_ = temp_result[nLoop];
				}
			}

			//deriveCorrelation ();
			//result_ = compareSelfCorrleation (CLOCK);

			break;

		} //switch
	}	//else




	printf ("WEIGHTED: <");
	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{
		printf ("%d,", WEIGHTED_AXIS [nLoop]);
	}
	printf (">\n");




	return result_;

}














///////////////////////////////// 2017.03.06 





#include "em_device.h"
#include "em_chip.h"
#include "em_usart.h"
#include "em_cmu.h"
#include "em_gpio.h"
#include "em_i2c.h"
#include "swCfg.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define WMA_FACTOR	3
//#undef WMA_FACTOR
#define WEIGHT	0.8
#undef WEIGHT
#define NORMALIZATION_FACTOR INT16_MAX

int16_t SENSOR [AXIS_NUM][SAMPLE_NUM];
#ifdef WMA_FACTOR
	#define WMA_SAMPLE_NUM	SAMPLE_NUM - WMA_FACTOR + 1
	int16_t WMA_SENSOR [AXIS_NUM][WMA_SAMPLE_NUM];
	int16_t WMA_temp [AXIS_NUM][WMA_SAMPLE_NUM];

#endif
#define CROSS_FACTOR	2
int8_t WEIGHTED_AXIS [6];
#define NUM_OF_DB	16
#define ELE_OF_DB	2
#define CIRCLE_THRESH	1

enum sensors_	{
	ACC_X,
	ACC_Y,
	ACC_Z,
	GY_X,
	GY_Y,
	GY_Z
};
int biggestValue [NUM_OF_DB];

int corr_int [AXIS_NUM][AXIS_NUM];


///////////////////////////////////////////////////////////////////////
void deriveCorrelation ()	{
///////////////////////////////////////////////////////////////////////
// A factor: The array of sensor data
// Return: NULL
//////////////////////////////////////////////////////////////////////

	float cov [AXIS_NUM][AXIS_NUM];
	float corr [AXIS_NUM][AXIS_NUM];
	float average [] = {0,0,0,0,0,0};
	int nLoop, nLoop2, nLoop3;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			average [nLoop] += SENSOR [nLoop][nLoop2];
		} //for nLoop2
		average [nLoop] /= SAMPLE_NUM;
	} //for nLoop



	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			cov [nLoop][nLoop2] = corr [nLoop][nLoop2] = corr_int[nLoop][nLoop2] = 0;
			for (nLoop3 = 0; nLoop3 < SAMPLE_NUM; nLoop3 ++)	{
				cov [nLoop][nLoop2] += (SENSOR [nLoop][nLoop3] - average [nLoop]) * (SENSOR [nLoop2][nLoop3] - average [nLoop2]);
			} // for nLoop3
			cov [nLoop][nLoop2] /= SAMPLE_NUM;

		} // for nLoop2
	} //for nLoop


	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = nLoop+1; nLoop2 < AXIS_NUM; nLoop2 ++)	{

			if (cov [nLoop][nLoop] * cov [nLoop2][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov [nLoop][nLoop] * cov [nLoop2][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;

			if ((corr [nLoop][nLoop2] < 0.5) && (corr [nLoop][nLoop2] > -0.5))	{	//filtering
				corr [nLoop][nLoop2] = 0;
			} //if
			else	{
				corr_int [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *100);
			}
		} //for nLoop2
	} //for nLoop

/*
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			printf ("%d\t", corr_int [nLoop][nLoop2] );
		}
		printf ("\n");
	}
	printf ("\n");
*/
} //function calculatCorrelation

//////////////////////////////////////////////////////////////////////
int compareSelfCorrleation (int db_id)	{
///////////////////////////////////////////////////////////////////////
// A factor: A DB id among 2, 3, 4, 5, 6, 7, 8, 9, 14, 15
// Return: detected DB id
//////////////////////////////////////////////////////////////////////

	int avg_gap [2] = {0,0};
	int result_ = 0;
	int nLoop, nLoop2, nLoop3;
	int filter_count = 0;
	float MIN = 10000.0;


	int total_db_count [2] = {22, 27};

	int db_corr [2][AXIS_NUM][AXIS_NUM] = {
			{		//for sensor1, CLOCK
					{0, 61, 00, 91, 69, 00 },
					{00, 00, 04, 59, 75, 00 },
					{00, 00, 00, 68, 25, 00 },
					{00, 00, 00, 00, 78, 00 },
					{00, 00, 00, 00, 00, 00 },
					{00, 00, 00, 00, 00, 00 },
				},

				{		//for sensor1, ANTI-CLOCK
					{00, 81, 59, -91, -83, -67 },
					{00, 00, -31, -81, -81, -91 },
					{00, 00, 00, -07, 55, -96 },
					{00, 00, 00, 00, 86, 98 },
					{00, 00, 00, 00, 00, 72 },
					{00, 00, 00, 00, 00, 00 },
				}
		};
	int db_count [2][AXIS_NUM][AXIS_NUM]= {
			{		//for sensor1, CLOCK
				{0, 3, 0, 21, 13, 0 },
				{0, 0, 4, 14, 16, 0 },
				{0, 0, 0, 6, 8, 0 } ,
				{0, 0, 0, 0, 16, 0 },
				{0, 0, 0, 0, 0, 0 },
				{0, 0, 0, 0, 0, 0 },
			},

			{		//for sensor1, ANTI-CLOCK
				{0, 18, 5, 24, 27, 1 },
				{0, 0, 12, 20, 25, 1 },
				{0, 0, 0, 4, 10, 1 },
				{0, 0, 0, 0, 27, 1 },
				{0, 0, 0, 0, 0, 1 },
				{0, 0, 0, 0, 0, 0 },
			},

	};

	for (nLoop = 0; nLoop < 2; nLoop ++)	{

		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			for (nLoop3 = nLoop2 + 1; nLoop3 < AXIS_NUM; nLoop3 ++)	{

				if ((db_count [nLoop][nLoop2][nLoop3] * 5) >  total_db_count [nLoop])	{
					avg_gap [nLoop] += abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]);
					filter_count ++;
					//printf ("%d\t", abs (corr_int [nLoop2][nLoop3] - db_corr [nLoop][nLoop2][nLoop3]));
				}


			} //for nLoop3
		} //for nLoop2

		if (filter_count == 0)
			filter_count ++;


		avg_gap [nLoop] /= filter_count;

		filter_count = 0;

		if ((avg_gap [nLoop] != 0) && (MIN > avg_gap [nLoop]))	{
			MIN = avg_gap [nLoop];
		}

	} //for nLoop


	if (avg_gap [0] < avg_gap [1])	{
		result_ = (db_id % 2 == 1) ? (db_id - 1) : (db_id);		//CLOCK
	}
	else	{
		result_ = (db_id % 2 == 1) ? (db_id) : (db_id + 1);		//ANTI-CLOCK
	}

	//printf ("<%d vs. %d> corr result is %d \n",  avg_gap[0],avg_gap[1], result_);

	return result_;
}


#ifdef WMA_FACTOR
void weightedMovingAverage (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{
	int nLoop, nLoop2, nLoop3;
	int16_t temp_avr;

	memset (WMA_SENSOR, '\0', sizeof(WMA_SENSOR));

	//printf ("<< WMA\n");
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < (SAMPLE_NUM - WMA_FACTOR + 1); nLoop2 ++)	{
			temp_avr = 0;
#ifndef WEIGHT
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR; nLoop3 ++)	{
				temp_avr +=  SENSOR [nLoop][nLoop2 + nLoop3];
			}
			WMA_SENSOR [nLoop][nLoop2] = temp_avr / WMA_FACTOR;

#else
			for (nLoop3 = 0; nLoop3 < WMA_FACTOR-1; nLoop3 ++)	{
				temp_avr +=  SENSOR [nLoop][nLoop2 + nLoop3];
			}
			temp_avr *= (1-WEIGHT);
			temp_avr += (WEIGHT * SENSOR [nLoop][nLoop2 + nLoop3]);
			WMA_SENSOR [nLoop][nLoop2] = temp_avr;
#endif
			//printf ("(%d)%d  ", nLoop2, WMA_SENSOR [nLoop][nLoop2]);
		}
		//printf ("\n");
	}
	//printf ("\n");
}
#endif



void compareOtherCorrelation (int arrayLen, int flag_, float db_sample[ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM], float db_average[ELE_OF_DB][AXIS_NUM], float db_cov[ELE_OF_DB][AXIS_NUM])	{

	int16_t WMA_SENSOR_local [AXIS_NUM][WMA_SAMPLE_NUM];
	int nLoopLen = 0, nLoopStart = 0;//, db_start = 0, db_end = 0;
	float average [AXIS_NUM];
	int nLoop, nLoop2, nLoop3;
	float cov [ELE_OF_DB][AXIS_NUM];
	float cov_self [AXIS_NUM];
	float corr [ELE_OF_DB][AXIS_NUM];
	float corr_int_local [ELE_OF_DB][AXIS_NUM];

	memset (cov, '\0', sizeof(cov));
	memset (average, '\0', sizeof(average));
	memset (cov_self, '\0', sizeof(cov_self));
	memset (corr, '\0', sizeof(corr));
	memset (corr_int_local, '\0', sizeof (corr_int_local));


	memset (WMA_SENSOR_local, '\0', sizeof(WMA_SENSOR_local));
	if (flag_ < 1)	{
		nLoopLen = arrayLen;
		nLoopStart = 0;
		memcpy (WMA_SENSOR_local, WMA_temp, sizeof(WMA_SENSOR_local));
	}
	else	{
		nLoopLen = WMA_SAMPLE_NUM;
		nLoopStart = flag_;
		memcpy (WMA_SENSOR_local, WMA_SENSOR, sizeof(WMA_SENSOR_local));
	}
/*
	switch (semi_result)	{
	case FRONT:
		db_start = FRONT;
		db_end = BACK;
		break;
	case SIDE:
		db_start = RIGHT;
		db_end = LEFT;
		break;
	case UP:
		db_start = UP;
		db_end = DOWN;
		break;
	default:
		db_start = CLOCK;
		db_end = SIDE_ANTI;
		break;
	}
	db_start = 0;
	db_end = NUM_OF_DB-1;


	int i;
	printf ("db_sample\n");
for (i = 0; i < 2; i ++)	{
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM; nLoop2 ++)	{
			printf ("%d ",(int)(db_sample[i][nLoop][nLoop2] * 10000));

		}
		printf ("\n");

	}
	printf ("\n");
}
	printf ("average & cov\n");
	for (i = 0; i < 2; i ++)	{

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		printf ("%d/%d ",(int)(db_average[i][nLoop] * 10000), (int)(db_cov [i][nLoop] * 10000));

	}		printf ("\n");
	}


*/

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{	//average of incoming sensor value
		for (nLoop2 = 0; nLoop2 < nLoopLen ; nLoop2 ++)	{
			average [nLoop] += WMA_SENSOR_local [nLoop][nLoop2];
		} //for nLoop2

		average [nLoop] /= nLoopLen;

	} //for nLoop

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		float temp_float=0;
		for (nLoop2 = nLoopStart; nLoop2 < nLoopLen; nLoop2 ++)	{ //covariance //분자계산
			temp_float = WMA_SENSOR_local [nLoop][nLoop2 - nLoopStart] - average [nLoop];

			for (nLoop3 = 0; nLoop3 < ELE_OF_DB; nLoop3 ++)
				cov [nLoop3][nLoop] += (temp_float * (db_sample [nLoop3][nLoop][nLoop2] - db_average [nLoop3][nLoop]));


			cov_self [nLoop] += (temp_float * temp_float);

		} //for nLoop2

		for (nLoop3 = 0; nLoop3 < ELE_OF_DB; nLoop3 ++)
			cov [nLoop3][nLoop] /= (nLoopLen - nLoopStart);

		cov_self [nLoop] /= (nLoopLen - nLoopStart);
	} // for nLoop

	int tempSUM [ELE_OF_DB];
	memset (tempSUM, 0, sizeof(tempSUM));
	//	printf ("----------------\ncorrelation(len: %d, flag: %d\n", arrayLen, flag_);

	//for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{	//correlation. //분모 계산
		for (nLoop = 0; nLoop <= 1; nLoop ++)	{	//correlation. //분모 계산

	//		printf ("(%d db)\t", nLoop);

		for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++)	{
			if (cov_self [nLoop2] * db_cov [nLoop][nLoop2])
				corr [nLoop][nLoop2] = cov [nLoop][nLoop2] / sqrt (cov_self [nLoop2] * db_cov [nLoop][nLoop2]);
			else
				corr [nLoop][nLoop2] = 0;

			corr_int_local [nLoop][nLoop2] = (int)(corr [nLoop][nLoop2] *100);
	//			printf ("%d(%d) ", (int)corr_int_local [nLoop][nLoop2], ((int)(corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2]) / 100));

			tempSUM [nLoop] += ((int)(corr_int_local [nLoop][nLoop2] * WEIGHTED_AXIS [nLoop2]) / 100);

		} //for nLoop2
			//printf (" --> %d \n", tempSUM[nLoop]);

		if (tempSUM[nLoop] < 20)
			 tempSUM[nLoop] = 0;
		else
			tempSUM[nLoop] *= tempSUM[nLoop];
	} //for nLoop

	//------------------------------------------------ deviation --------------
		int gap_mean [NUM_OF_DB][AXIS_NUM];
		int gap_deviation [NUM_OF_DB][AXIS_NUM];
		memset (gap_mean, 0x0, sizeof(gap_mean));
		memset (gap_deviation, 0x0, sizeof(gap_deviation));


		int tempSUM_dev [NUM_OF_DB];
		memset (tempSUM_dev, 0, sizeof(tempSUM_dev));

	//	printf ("GAP dev!\n");

		//for (nLoop = 0; nLoop < NUM_OF_DB; nLoop ++)	{
		for (nLoop = 0; nLoop <= 1; nLoop ++)	{
			for (nLoop2 = 0; nLoop2 < AXIS_NUM; nLoop2 ++){
				for (nLoop3 = nLoopStart; nLoop3 < nLoopLen; nLoop3 ++){
					gap_mean [nLoop][nLoop2] += abs( (int)(db_sample [nLoop][nLoop2][nLoop3] * 1000) - (int) WMA_SENSOR_local[nLoop2][nLoop3]);
				}
				gap_mean [nLoop][nLoop2] /= nLoopLen;

				for (nLoop3 = nLoopStart; nLoop3 < nLoopLen; nLoop3 ++){
					gap_deviation [nLoop][nLoop2] += abs( (int)(db_sample [nLoop][nLoop2][nLoop3] * 1000) - (int)WMA_SENSOR_local[nLoop2][nLoop3] - (int)gap_mean [nLoop][nLoop2] );
				}

				gap_deviation [nLoop][nLoop2] /= nLoopLen;
		//			printf ("(%d:%d)%d ", nLoop, nLoop2, gap_deviation [nLoop][nLoop2]);

				tempSUM_dev [nLoop] +=  gap_deviation [nLoop][nLoop2];
			}
		//	printf (" ==) %d\n", tempSUM_dev [nLoop]);

		}
		//	printf ("\n");


		int temp_int;
		//printf ("result is ");
		for (nLoop = 0; nLoop <= 1; nLoop ++)	{
			if (tempSUM [nLoop] > 0)	{
				temp_int = (int)((tempSUM [nLoop] * 1000) / tempSUM_dev [nLoop]);
			//	temp_int = tempSUM [nLoop];
				//printf ("(%d)%d-%d, ", nLoop, tempSUM [nLoop], temp_int);

			}
			else	{
				temp_int = 0;
		//		printf ("0, ");
			}

			if (biggestValue [nLoop] < temp_int)
				biggestValue [nLoop] = temp_int;
		}
		//printf ("\n");

}


void normalizingFunction (int16_t sensor [AXIS_NUM][SAMPLE_NUM]){
	int nLoop, nLoop2;

	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			SENSOR [nLoop][nLoop2] = (int)(((float)sensor [nLoop][nLoop2] / NORMALIZATION_FACTOR) * 1000);
		}
	}

}




int crossCorrelation (float db_sample[ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM], float db_average[ELE_OF_DB][AXIS_NUM], float db_cov[ELE_OF_DB][AXIS_NUM])	{

	int nLoop, nLoop2, max_ = 0, db_num = 0, result_ = 0;
	memset (WMA_temp, '\0', sizeof(WMA_SAMPLE_NUM));
	biggestValue [0] = biggestValue [1] = 0;


	for (nLoop = -CROSS_FACTOR; nLoop < 1; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM + nLoop ; nLoop2 ++)	{
			WMA_temp [0][nLoop2] = WMA_SENSOR [0][-nLoop+ nLoop2];
			WMA_temp [1][nLoop2] = WMA_SENSOR [1][-nLoop+ nLoop2];
			WMA_temp [2][nLoop2] = WMA_SENSOR [2][-nLoop+ nLoop2];
			WMA_temp [3][nLoop2] = WMA_SENSOR [3][-nLoop+ nLoop2];
			WMA_temp [4][nLoop2] = WMA_SENSOR [4][-nLoop+ nLoop2];
			WMA_temp [5][nLoop2] = WMA_SENSOR [5][-nLoop+ nLoop2];
		}
		compareOtherCorrelation (WMA_SAMPLE_NUM + nLoop, nLoop, db_sample, db_average, db_cov);
	}
	for (nLoop = 1; nLoop < CROSS_FACTOR; nLoop ++)	{
		compareOtherCorrelation (WMA_SAMPLE_NUM, nLoop, db_sample, db_average, db_cov);
	}

	printf ("biggest value: ");
	for (nLoop = 0; nLoop < ELE_OF_DB; nLoop ++)	{
		printf ("%d ",  biggestValue [nLoop]);
		if (biggestValue [nLoop] > max_)	{
			max_ = biggestValue [nLoop];
			db_num = nLoop;
		}
	}
	printf ("\n");


	result_ = biggestValue [0] > biggestValue [1] ? 0 : 1;
	return result_;

}



int assignDB_FRONT (void)	{
	int result_;
	printf ("\nassign DB Front\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{ //front
			{-0.0120 ,-0.0290 ,-0.0990 ,-0.0850 ,-0.0360 ,0.1230 ,0.1430 ,0.0860 ,0.0450 ,0.0780 ,0.1370 ,0.1210 ,0.0620 ,0.0290 ,0.0170 ,0.0140 ,0.0080 ,-0.0230 },
			{0.0300 ,0.0890 ,0.2420 ,0.3830 ,0.4060 ,0.2090 ,-0.1160 ,-0.3530 ,-0.3880 ,-0.2590 ,-0.1710 ,-0.1680 ,-0.1700 ,-0.0820 ,0.0090 ,0.0750 ,0.1080 ,0.1060},
			{0.5030 ,0.5110 ,0.4470 ,0.5130 ,0.4920 ,0.5650 ,0.4880 ,0.4540 ,0.4350 ,0.4370 ,0.4890 ,0.5240 ,0.4930 ,0.4720 ,0.4580 ,0.5010 ,0.5190 ,0.5060 },
			{0.0000 ,-0.0040 ,-0.0010 ,-0.0050 ,-0.0090 ,-0.0010 ,-0.0240 ,-0.0330 ,-0.0350 ,0.0000 ,0.0190 ,0.0150 ,0.0190 ,0.0350 ,0.0310 ,0.0140 ,-0.0020 ,-0.0090},
			{0.0000 ,0.0010 ,-0.0150 ,-0.0380 ,-0.0540 ,-0.0320 ,0.0160 ,0.0340 ,0.0010 ,-0.0130 ,-0.0080 ,0.0300 ,0.0210 ,0.0060 ,-0.0060 ,-0.0010 ,0.0160 ,0.0200 },
			{0.0000 ,-0.0040 ,-0.0320 ,-0.0250 ,-0.0270 ,-0.0130 ,-0.0410 ,-0.0420 ,-0.0200 ,0.0070 ,0.0240 ,0.0300 ,0.0380 ,0.0410 ,0.0330 ,0.0210 ,0.0080 ,0.0050}
		},
		{// back
			{0.0380 ,0.0650 ,0.0630 ,0.0790 ,0.0650 ,0.0470 ,0.0120 ,-0.0310 ,-0.0500 ,-0.0710 ,-0.0510 ,-0.0230 ,0.0050 ,0.0160 ,0.0200 ,0.0160 ,0.0130 ,0.0120},
			{-0.0240 ,-0.1110 ,-0.2300 ,-0.2890 ,-0.2000 ,0.0650 ,0.3430 ,0.4490 ,0.3320 ,0.1480 ,0.0450 ,0.0240 ,0.0220 ,0.0100 ,0.0020 ,0.0060 ,0.0140 ,0.0220 },
			{0.5120 ,0.5280 ,0.5080 ,0.5090 ,0.4570 ,0.4840 ,0.4780 ,0.4930 ,0.5150 ,0.5610 ,0.5720 ,0.5320 ,0.4950 ,0.5140 ,0.5220 ,0.5170 ,0.5090 ,0.5080 },
			{0.0020 ,0.0070 ,0.0140 ,0.0160 ,0.0140 ,-0.0020 ,0.0040 ,0.0010 ,0.0070 ,-0.0070 ,-0.0090 ,-0.0110 ,-0.0080 ,-0.0060 ,-0.0020 ,0.0010 ,0.0010 ,0.0000},
			{0.0010 ,0.0010 ,-0.0050 ,-0.0060 ,0.0000 ,0.0260 ,0.0620 ,0.0480 ,0.0110 ,-0.0260 ,-0.0230 ,-0.0090 ,-0.0150 ,-0.0110 ,-0.0060 ,0.0000 ,0.0020 ,0.0010 },
			{0.0010 ,0.0040 ,0.0150 ,0.0360 ,0.0450 ,0.0360 ,0.0140 ,-0.0100 ,-0.0180 ,-0.0170 ,-0.0020 ,0.0070 ,0.0060 ,0.0030 ,-0.0020 ,-0.0040 ,-0.0040 ,-0.0020 }

		},
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0322,-0.0028,0.4893,0.0006,-0.0012,0.0002},	//front
			{0.0125,0.0349,0.5119,0.0012,0.0028,0.0060}	//back
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.00534, 0.05293, 0.00114, 0.00037, 0.00054, 0.00074},	//front
			{0.00191, 0.03687, 0.00073, 0.00006, 0.00050, 0.00030}	//back
	};


	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = BACK;
	else
		result_ = FRONT;

	return result_;
}

int assignDB_RIGHT (void)	{
	int result_;
	printf ("\nassign DB Right\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{ //right
			{0.0540 , 0.1750 , 0.3180 , 0.3830 , 0.2940 , 0.0710 , -0.1720 , -0.3040 , -0.2730 , -0.1470 , -0.0280 , 0.0250 , 0.0360 , 0.0400 , 0.0510 , 0.0640 , 0.0740 , 0.0780 },
			{-0.0150 , 0.0130 , 0.0270 , 0.0420 , -0.0120 , -0.0760 , -0.1430 , -0.1340 , -0.0760 , -0.0120 , 0.0320 , 0.0430 , 0.0330 , 0.0200 , 0.0220 , 0.0280 , 0.0380 , 0.0380 },
			{0.5100 , 0.5400 , 0.5730 , 0.5340 , 0.4940 , 0.4110 , 0.4790 , 0.5210 , 0.5850 , 0.5470 , 0.5180 , 0.4950 , 0.4940 , 0.5050 , 0.5150 , 0.5140 , 0.5060 , 0.5010},
			{0.0020 , 0.0060 , 0.0170 , 0.0300 , 0.0310 , 0.0220 , -0.0020 , -0.0120 , -0.0150 , -0.0030 , 0.0030 , 0.0030 , 0.0000 , -0.0030 , -0.0030 , -0.0010 , 0.0010 , 0.0000},
			{-0.0050 , -0.0150 , -0.0220 , -0.0170 , -0.0060 , -0.0130 , -0.0330 , -0.0400 , -0.0230 , -0.0020 , 0.0040 , 0.0030 , 0.0000 , -0.0040 , -0.0030 , -0.0010 , 0.0000 , -0.0010},
			{0.0000 , -0.0080 , -0.0290 , -0.0670 , -0.1030 , -0.1260 , -0.1080 , -0.0680 , -0.0200 , 0.0060 , 0.0110 , 0.0080 , 0.0040 , 0.0060 , 0.0090 , 0.0090 , 0.0060 , 0.0030}
		},
		{ //left
			{0.009000 , -0.090000 , -0.243000 , -0.299000 , -0.184000 , 0.047000 , 0.253000 , 0.367000 , 0.361000 , 0.250000 , 0.112000 , 0.031000 , 0.014000 , 0.012000 , 0.016000 , 0.021000 , 0.032000 , 0.037000},
			{0.002000 , 0.016000 , -0.046000 , -0.080000 , -0.091000 , -0.036000 , 0.022000 , 0.050000 , 0.056000 , 0.027000 , -0.024000 , -0.043000 , -0.040000 , -0.039000 , -0.032000 , -0.024000 , -0.022000 , -0.024000 },
			{0.510000 , 0.521000 , 0.567000 , 0.559000 , 0.526000 , 0.471000 , 0.436000 , 0.464000 , 0.486000 , 0.496000 , 0.505000 , 0.506000 , 0.535000 , 0.519000 , 0.500000 , 0.507000 , 0.515000 , 0.524000 },
			{0.002000 , 0.011000 , 0.015000 , 0.012000 , -0.001000 , -0.007000 , -0.006000 , -0.007000 , -0.006000 , -0.013000 , -0.011000 , -0.012000 , -0.005000 , -0.003000 , -0.002000 , -0.003000 , -0.004000 , -0.004000 },
			{-0.002000 , -0.005000 , -0.003000 , 0.007000 , 0.009000 , 0.008000 , -0.002000 , -0.009000 , 0.000000 , 0.006000 , 0.009000 , 0.002000 , -0.002000 , 0.003000 , 0.001000 , 0, 0 , 0.001000 },
			{0, 0, 0.008000 , 0.042000 , 0.082000 , 0.105000 , 0.087000 , 0.042000 , 0.004000 , -0.021000 , -0.026000 , -0.025000 , -0.020000 , -0.013000 , -0.010000 , -0.007000 , -0.006000 , -0.005000 }

		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0411, -0.0073, 0.5134, 0.0042, -0.0099, -0.0259},	//right
			{0.04144, -0.0182, 0.5082, -0.0024, 0.0013, 0.0132} 	//left
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.0343, 0.0036, 0.0014, 0.0002, 0.0002, 0.0022}, 	//right
			{0.03354, 0.0016, 0.0010, 0.0001, 0.00001, 0.0017} //left
	};


	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ =LEFT ;
	else
		result_ = RIGHT;
	return result_;
}

int assignDB_UP (void)	{
	int result_;
	printf ("\nassign DB UP\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
			{	//UP
				{0.0040 , 0.0110 , 0.0220 , 0.0280 , 0.0180 , -0.0080 , -0.0260 , -0.0310 , -0.0200 , -0.0100 , -0.0060 , -0.0080 , -0.0120 , -0.0140 , -0.0080 , 0.0010 , 0.0100 , 0.0140},
				{-0.0430 , -0.0610 , -0.0090 , -0.0230 , -0.0010 , -0.0740 , -0.0390 , 0.0110 , 0.0630 , 0.0740 , 0.0750 , 0.0720 , 0.0650 , 0.0580 , 0.0590 , 0.0620 , 0.0680 , 0.0700},
				{0.5120 , 0.5790 , 0.7410 , 0.8000 , 0.6800 , 0.3420 , 0.1240 , 0.0810 , 0.2040 , 0.3460 , 0.4540 , 0.5140 , 0.5540 , 0.5490 , 0.5430 , 0.5190 , 0.5150 , 0.5050},
				{-0.0030 , -0.0300 , -0.0040 , 0.0200 , 0.0610 , 0.0460 , 0.0310 , 0.0190 , 0.0070 , -0.0050 , -0.0110 , -0.0110 , -0.0080 , -0.0030 , 0.0020 , 0.0040 , 0.0050 , 0.0030},
				{0.0000 , -0.0110 , -0.0050 , 0.0020 , 0.0240 , 0.0250 , 0.0110 , -0.0040 , -0.0140 , -0.0120 , -0.0100 , -0.0080 , -0.0050 , -0.0010 , 0.0000 , 0.0000 , 0.0020 , 0.0030},
				{0.0000 , 0.0110 , 0.0190 , 0.0230 , 0.0070 , -0.0090 , -0.0180 , -0.0170 , -0.0130 , -0.0090 , -0.0070 , -0.0050 , -0.0030 , -0.0010 , 0.0010 , 0.0020 , 0.0020 , 0.0010}

			},
			{	//down
				{-0.0240 , -0.0470 , -0.0970 , -0.0870 , 0.0180 , 0.1270 , 0.1350 , 0.0690 , 0.0280 , 0.0160 , 0.0100 , 0.0000 , -0.0060 , 0.0000 , 0.0110 , 0.0200 , 0.0180 , 0.0120 },
				{0.0500 , 0.0210 , 0.0260 , -0.0430 , 0.0090 , 0.0010 , 0.0250 , -0.0260 , -0.0530 , -0.0290 , -0.0390 , -0.0400 , -0.0420 , -0.0420 , -0.0430 , -0.0430 , -0.0500 , -0.0420},
				{0.4500 , 0.2100 , -0.0560 , -0.0340 , 0.3720 , 0.8250 , 0.8800 , 0.7350 , 0.5840 , 0.5360 , 0.5120 , 0.4930 , 0.4930 , 0.4970 , 0.5140 , 0.5230 , 0.5180 , 0.4990},
				{0.0170 , 0.0120 , -0.0150 , -0.0590 , -0.0980 , -0.0930 , -0.0580 , -0.0240 , -0.0060 , -0.0060 , 0.0000 , 0.0010 , 0.0000 , -0.0020 , -0.0050 , -0.0040 , 0.0000 , 0.0060},
				{0.0500 , 0.0810 , 0.0410 , -0.0700 , -0.1190 , -0.0700 , 0.0080 , 0.0180 , -0.0030 , -0.0060 , -0.0040 , -0.0040 , -0.0040 , -0.0040 , -0.0030 , 0.0030 , 0.0070 , 0.0060},
				{0.0020 , 0.0050 , 0.0060 , 0.0050 , 0.0080 , 0.0000 , 0.0010 , -0.0060 , 0.0000 , 0.0000 , 0.0010 , 0.0000 , 0.0000 , 0.0000 , 0.0010 , 0.0000 , -0.0010 , -0.0010},
			}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{-0.0019, 0.0237, 0.4757, 0.0068, -0.0002, -0.0009},	//up
			{0.0113, -0.0200, 0.4751, -0.0186, -0.0041, 0.0012} 	//down
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.0003, 0.0028, 0.0376, 0.0005, 0.0001, 0.0001}, 	//up
			{0.0035, 0.0011, 0.0589, 0.0012, 0.0021, 0.00001}	//down
	};


	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = DOWN;
	else
		result_ = UP;
	return result_;

}

int assignDB_CLOCK (void)	{
	int result_;
	printf ("\nassign DB Clk\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{ //CLOCK
			{0.0955 , 0.2635 , 0.3904 , 0.4570 , 0.4397 , 0.2961 , 0.0711 , -0.2096 , -0.4202 , -0.5015 , -0.3693 , -0.1749 , 0.0070 , 0.0755 , 0.0992 , 0.0825 , 0.0641 , 0.0245 },
			{-0.0409 , -0.0365 , -0.0492 , -0.0303 , -0.0183 , -0.0530 , -0.0996 , -0.1998 , -0.2290 , -0.2101 , -0.1068 , -0.0007 , 0.0223 , 0.0035 , -0.0563 , -0.0780 , -0.0772 , -0.0604 },
			{0.9343 , 0.8526 , 0.6681 , 0.3260 , 0.1101 , -0.0960 , -0.1095 , -0.0322 , 0.2818 , 0.5574 , 0.7934 , 0.8148 , 0.8499 , 0.7628 , 0.7038 , 0.6051 , 0.5729 , 0.5071 },
			{0.0949 , 0.1808 , 0.2183 , 0.1990 , 0.1479 , 0.0787 , -0.0041 , -0.0802 , -0.1401 , -0.1749 , -0.1750 , -0.1497 , -0.1059 , -0.0689 , -0.0285 , -0.0084 , 0.0057 , 0.0033 },
			{-0.0535 , -0.0383 , 0.0024 , 0.0002 , -0.0190 , -0.0616 , -0.0948 , -0.1254 , -0.1309 , -0.0935 , -0.0330 , 0.0154 , 0.0333 , 0.0384 , 0.0279 , 0.0194 , 0.0102 , 0.0106 },
			{0.1447 , 0.0909 , 0.0195 , -0.0454 , -0.1270 , -0.1813 , -0.2095 , -0.1864 , -0.1162 , -0.0189 , 0.0760 , 0.1204 , 0.1333 , 0.1138 , 0.0885 , 0.0553 , 0.0289 , 0.0085 }

		},
		{ //ANTI-CLOCK
			{0.1536 , -0.2041 , -0.3660 , -0.3371 , -0.2394 , -0.1310 , -0.0166 , 0.0971 , 0.1728 , 0.2668 , 0.3068 , 0.2842 , 0.1848 , 0.0856 , 0.0062 , -0.0730 , -0.1335 , -0.1470 },
			{-0.1114 , -0.3936 , -0.4661 , -0.4337 , -0.2992 , -0.1715 , -0.0327 , 0.0819 , 0.1073 , 0.0832 , 0.0411 , 0.0020 , -0.0990 , -0.1627 , -0.1772 , -0.1342 , -0.1240 , -0.1206 },
			{0.8617 , 0.9261 , 0.8838 , 0.6318 , 0.3124 , 0.0442 , -0.0956 , -0.1198 , 0.0114 , 0.2855 , 0.5566 , 0.7435 , 0.7857 , 0.7948 , 0.7607 , 0.6815 , 0.5950 , 0.5346 },
			{0.0273 , 0.0842 , 0.1378 , 0.1700 , 0.1474 , 0.0836 , 0.0106 , -0.0626 , -0.1188 , -0.1643 , -0.1755 , -0.1649 , -0.1205 , -0.0654 , -0.0207 , 0.0017 , 0.0102 , 0.0143 },
			{0.0063 , 0.0011 , 0.0328 , 0.0913 , 0.1344 , 0.1259 , 0.1043 , 0.0681 , 0.0230 , -0.0114 , -0.0069 , 0.0084 , 0.0073 , -0.0097 , -0.0118 , 0.0063 , 0.0124 , 0.0131 },
			{-0.2334 , -0.2022 , -0.0971 , 0.0079 , 0.0877 , 0.1477 , 0.1952 , 0.1990 , 0.1613 , 0.1021 , 0.0317 , -0.0307 , -0.0822 , -0.1063 , -0.1069 , -0.0932 , -0.0673 , -0.0412 	}
		},
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0384, -0.0733, 0.5057, -0.0004, -0.0273, -0.0003}, //clock
			{-0.0050, -0.1339, 0.5108, -0.0114, 0.0330, -0.0071} //ANTI-clock
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.0759, 0.0050, 0.1121, 0.0158, 0.0028, 0.0131},	//CLOCK
			{0.0421, 0.0285, 0.1158, 0.0114, 0.0023, 0.0163}	//ANTI-CLOCK
	};


	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = ANTI_CLOCK;
	else
		result_ = CLOCK;
	return result_;

}

int assignDB_LOW (void)	{
	int result_;
	printf ("\nassign DB Low\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{ //LOW CLOCK
			{0.3006 , 0.3424 , 0.3616 , 0.3218 , 0.2365 , 0.1268 , 0.0348 , -0.0595 , -0.1366 , -0.2006 , -0.2176 , -0.1927 , -0.1407 , -0.0507 , 0.0183 , 0.0903 , 0.0999 , 0.0949 },
			{0.1700 , 0.1202 , -0.0088 , -0.1808 , -0.2990 , -0.3368 , -0.2961 , -0.2510 , -0.1992 , -0.1522 , -0.0834 , -0.0190 , 0.0253 , 0.0719 , 0.0642 , 0.0596 , 0.0109 , -0.0116},
			{0.5936 , 0.5105 , 0.4762 , 0.4848 , 0.4739 , 0.4619 , 0.4485 , 0.4307 , 0.4674 , 0.5326 , 0.6218 , 0.6579 , 0.6215 , 0.5714 , 0.5328 , 0.5451 , 0.5481 , 0.5459},
			{0.0424 , 0.0388 , 0.0259 , 0.0277 , 0.0150 , 0.0089 , -0.0023 , -0.0146 , -0.0343 , -0.0444 , -0.0397 , -0.0220 , -0.0053 , 0.0012 , 0.0016 , 0.0028 , 0.0026 , 0.0015},
			{-0.0209 , -0.0085 , -0.0046 , 0.0032 , 0.0024 , -0.0102 , -0.0248 , -0.0350 , -0.0387 , -0.0340 , -0.0158 , 0.0087 , 0.0263 , 0.0258 , 0.0199 , 0.0114 , 0.0149 , 0.0144 },
			{0.0545 , -0.0140 , -0.0798 , -0.1114 , -0.1173 , -0.0899 , -0.0649 , -0.0461 , -0.0343 , -0.0190 , 0.0032 , 0.0261 , 0.0493 , 0.0662 , 0.0693 , 0.0661 , 0.0546 , 0.0458}
		},
		{ //LOW ANTI
			{0.1573 , 0.0709 , -0.0684 , -0.1793 , -0.2324 , -0.2304 , -0.1262 , 0.0454 , 0.2397 , 0.3674 , 0.4178 , 0.4139 , 0.3993 , 0.3387 , 0.2261 , 0.0797 , -0.0449 , -0.0944 },
			{0.1311 , 0.1593 , 0.0867 , -0.0606 , -0.2740 , -0.4536 , -0.5189 , -0.4771 , -0.3686 , -0.2549 , -0.1614 , -0.0310 , 0.0442 , 0.1334 , 0.1017 , 0.0703 , -0.0309 , -0.0758},
			{0.5781 , 0.6344 , 0.6500 , 0.7000 , 0.5991 , 0.5298 , 0.3672 , 0.3612 , 0.3605 , 0.3965 , 0.4605 , 0.5343 , 0.5890 , 0.6164 , 0.6203 , 0.6092 , 0.5857 , 0.5742 },
			{-0.0082 , -0.0014 , -0.0030 , 0.0220 , 0.0284 , 0.0448 , 0.0199 , 0.0129 , -0.0040 , -0.0155 , -0.0296 , -0.0421 , -0.0619 , -0.0673 , -0.0563 , -0.0247 , 0.0031 , 0.0179},
			{-0.0161 , -0.0257 , -0.0311 , -0.0139 , 0.0320 , 0.0536 , 0.0532 , 0.0122 , -0.0107 , -0.0320 , -0.0445 , -0.0323 , 0.0026 , 0.0309 , 0.0284 , 0.0062 , -0.0175 , -0.0177 },
			{-0.0617 , -0.1022 , -0.1290 , -0.1193 , -0.0908 , -0.0126 , 0.0854 , 0.1786 , 0.2294 , 0.2139 , 0.1750 , 0.1055 , 0.0399 , -0.0448 , -0.1064 , -0.1503 , -0.1464 , -0.1117 }
		},
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0572, -0.0731, 0.5291, 0.0003, -0.0036, -0.0079}, //LOW CLOCK
			{0.0989, -0.1100, 0.5426, -0.0092, -0.0012, -0.0026} //LOW ANTI
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.0363, 0.0232, 0.0041, 0.0006, 0.0004, 0.0040},	//LOW CLOCK
			{0.0498, 0.0491, 0.0108, 0.0010, 0.0009, 0.0169}	//LOW ANTI
	};


	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = LOW_ANTI;
	else
		result_ = LOW_CLOCK;
	return result_;


}

int assignDB_SIDE ()	{

	int result_;
	printf ("\nassign DB Side\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{	//SIDE-CLK
			{0.0110 , 0.0720 , 0.1490 , 0.1750 , 0.1200 , 0.0560 , 0.0450 , 0.1130 , 0.1660 , 0.1770 , 0.1330 , 0.1240 , 0.1910 , 0.2280 , 0.2730 , 0.2270 , 0.1580 , 0.0660 },
			{0.0520 , 0.0350 , -0.1210 , -0.3610 , -0.5450 , -0.5440 , -0.3260 , 0.0290 , 0.3610 , 0.5520 , 0.4910 , 0.3100 , 0.1120 , -0.0080 , -0.0760 , -0.2050 , -0.3110 , -0.3360 },
			{0.4590 , 0.6430 , 0.8420 , 0.9320 , 0.6840 , 0.3330 , -0.0450 , -0.1830 , -0.2640 , -0.1010 , 0.1440 , 0.5300 , 0.8140 , 0.9220 , 0.8160 , 0.6400 , 0.4800 , 0.4310 },
			{-0.0220 , -0.0260 , 0.0110 , 0.0820 , 0.1400 , 0.1510 , 0.1090 , 0.0270 , -0.0590 , -0.1350 , -0.1970 , -0.2030 , -0.1460 , -0.0460 , 0.0160 , 0.0450 , 0.0230 , 0.0080 },
			{-0.0230 , -0.0430 , 0.0030 , 0.0890 , 0.1660 , 0.1630 , 0.0950 , 0.0350 , -0.0120 , -0.0470 , -0.0610 , -0.0890 , -0.0850 , -0.0710 , -0.0090 , 0.0380 , 0.0580 , 0.0420 },
			{-0.0090 , -0.0230 , -0.0430 , -0.0370 , 0.0090 , 0.0880 , 0.1430 , 0.1550 , 0.1130 , 0.0330 , -0.0390 , -0.0800 , -0.0930 , -0.0870 , -0.0840 , -0.0690 , -0.0550 , -0.0260 }
		},
		{	//SIDE-ANTI
			{0.0110 , 0.0100 , 0.0210 , 0.0520 , 0.1120 , 0.1620 , 0.1790 , 0.1020 , -0.0460 , -0.1480 , -0.1840 , -0.1070 , -0.0430 , 0.0100 , 0.0450 , 0.0860 , 0.1370 , 0.1500 },
			{-0.0190 , -0.0400 , -0.1110 , -0.2290 , -0.3390 , -0.3480 , -0.2930 , -0.1610 , -0.0380 , 0.2160 , 0.4010 , 0.5070 , 0.3370 , 0.0480 , -0.2390 , -0.4040 , -0.4230 , -0.3330 },
			{0.4810 , 0.4110 , 0.3430 , 0.3240 , 0.4810 , 0.6930 , 0.9020 , 0.8350 , 0.7220 , 0.4140 , 0.3500 , 0.1240 , 0.0780 , -0.0810 , 0.0350 , 0.1930 , 0.4090 , 0.5430 },
			{0.0050 , -0.0070 , -0.0340 , -0.0730 , -0.0940 , -0.0860 , -0.0290 , 0.0740 , 0.1660 , 0.1860 , 0.1510 , 0.0880 , 0.0470 , -0.0230 , -0.0900 , -0.1440 , -0.1490 , -0.1120 },
			{0.0000 , -0.0100 , -0.0200 , -0.0390 , -0.0470 , -0.0080 , 0.0690 , 0.1180 , 0.1000 , 0.0630 , 0.0200 , 0.0120 , -0.0260 , -0.0460 , -0.0850 , -0.0960 , -0.0880 , -0.0780 },
			{-0.0130 , -0.0120 , -0.0040 , 0.0050 , 0.0210 , 0.0310 , 0.0360 , 0.0310 , 0.0350 , 0.0560 , 0.0550 , 0.0240 , -0.0320 , -0.0610 , -0.0530 , -0.0190 , 0.0140 , 0.0340 }
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.1380, -0.0495, 0.4487, -0.0123, 0.0138, -0.0058},	//side-clk
			{0.0305, -0.0816, 0.4032, -0.0069, -0.0089, 0.0082} 	//side-anti
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.00490, 0.10865, 0.1516, 0.01107, 0.00612, 0.00641},	//side-clk
			{0.01116, 0.08157, 0.07431, 0.01101, 0.00406, 0.00117}	//side-anti

	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = SIDE_ANTI;
	else
		result_ = SIDE_CLOCK;

	return result_;
}




int assignDB_FRONT_RL ()	{

	int result_;
	printf ("\nassign DB FRONT-RightLeft\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{	//FRONT-RIGHT
			{-0.001, -0.03, -0.016, 0.01, 0.112, 0.035, 0.061, 0.154, 0.463, 0.606, 0.414, -0.044, -0.423, -0.468, -0.259, -0.072, 0.023, 0.05},
			{-0.023, 0.055, 0.218, 0.259, -0.019, -0.376, -0.498, -0.302, -0.029, 0.087, -0.035, -0.27, -0.352, -0.231, -0.02, 0.03, 0.057, 0.019},
			{0.461, 0.499, 0.531, 0.529, 0.504, 0.479, 0.499, 0.506, 0.536, 0.51, 0.461, 0.499, 0.531, 0.529, 0.504, 0.479, 0.499, 0.506},
			{-0.022, -0.05, -0.064, -0.012, 0.07, 0.079, 0.043, 0.013, 0.033, 0.021, -0.008, -0.022, -0.02, -0.005, 0.001, 0.01, 0.005, 0.002},
			{-0.007, -0.018, -0.035, -0.016, 0.051, 0.079, 0.025, -0.047, -0.067, -0.029, -0.002, 0.001, 0.011, -0.003, 0, -0.012, -0.011, -0.01},
			{0.005, 0.009, 0.01, -0.021, -0.039, -0.038, 0.015, 0.047, 0.044, -0.044, -0.158, -0.199, -0.135, -0.023, 0.031, 0.038, 0.027, 0.015}
		},
		{	//FRONT-LEFT
			{-0.033, -0.049, -0.047, 0.008, 0.131, 0.073, 0.03, -0.119, -0.245, -0.437, -0.29, 0.123, 0.467, 0.438, 0.24, 0.092, 0.021, -0.004},
			{-0.024, 0.053, 0.224, 0.398, 0.255, -0.211, -0.475, -0.431, -0.236, -0.28, -0.208, -0.081, 0.077, 0.011, -0.03, -0.079, -0.085, -0.074},
			{0.509, 0.534, 0.698, 0.721, 0.621, 0.359, 0.365, 0.439, 0.583, 0.553, 0.494, 0.41, 0.425, 0.479, 0.52, 0.532, 0.547, 0.548},
			{-0.004, -0.012, -0.007, 0.002, 0.057, 0.021, 0.002, -0.043, -0.025, -0.002, -0.012, -0.011, -0.021, -0.009, 0.002, 0.001, 0.002, 0.005},
			{-0.003, -0.005, -0.034, -0.038, -0.014, 0.012, -0.003, -0.015, -0.019, 0.004, 0.013, 0.007, 0, -0.02, -0.005, -0.002, 0.003, 0.002},
			{-0.006, -0.001, 0.008, -0.004, -0.027, -0.065, -0.043, -0.025, 0.018, 0.052, 0.108, 0.102, 0.059, -0.003, -0.02, -0.022, -0.018, -0.01}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			{0.0342, -0.0794, 0.5034, 0.0041, -0.0050, -0.0231},	//FRONT-RIGHT
			{0.0222, -0.0664, 0.5187, -0.0030, -0.0065, 0.0057}  	//FRONT-LEFT
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			{0.073508, 0.04413, 0.00051, 0.00134, 0.00111, 0.00512},	//FRONT-RIGHT
			{0.050656, 0.05078, 0.00996, 0.00041, 0.00020, 0.00217}	//FRONT-LEFT
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = FRONT_L;
	else
		result_ = FRONT_R;

	return result_;
}





int assignDB_BACK_RL ()	{

	int result_;
	printf ("\nassign DB BACK-RightLeft\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{	//BACK-RIGHT
			{-0.016, 0.029, 0.065, 0.011, 0.048, 0.112, 0.277, 0.349, 0.441, 0.403, 0.087, -0.275, -0.428, -0.244, 0.008, 0.11, 0.11, 0.075},
			{0.008, -0.233, -0.462, -0.389, -0.115, 0.236, 0.291, 0.238, 0.06, -0.052, -0.163, -0.267, -0.216, -0.1, 0.037, 0, -0.011, -0.037},
			{0.477, 0.513, 0.574, 0.518, 0.618, 0.632, 0.661, 0.389, 0.37, 0.358, 0.529, 0.537, 0.654, 0.628, 0.563, 0.502, 0.486, 0.5},
			{0.006, 0.006, 0, -0.015, -0.047, -0.038, -0.021, 0.011, -0.002, 0.004, 0.007, -0.012, -0.02, -0.027, 0, 0.002, 0.002, 0},
			{0.001, -0.023, -0.035, -0.016, -0.019, 0.003, 0.016, 0.042, 0.006, -0.033, -0.045, -0.05, -0.033, -0.02, 0.005, 0.003, 0.003, 0.003},
			{-0.003, -0.012, 0.015, 0.041, 0.097, 0.085, 0.057, -0.017, -0.046, -0.08, -0.118, -0.128, -0.098, -0.027, 0, 0.001, -0.006, -0.008}
		},
		{	//BACK-LEFT
			{0.064, 0.07, 0.057, 0.052, 0.061, 0.076, 0.059, 0.025, -0.086, -0.265, -0.379, -0.238, 0.034, 0.271, 0.312, 0.266, 0.164, 0.077},
			{-0.081, -0.164, -0.272, -0.369, -0.344, -0.136, 0.14, 0.388, 0.413, 0.296, -0.026, -0.202, -0.231, -0.117, -0.088, -0.086, -0.078, -0.069},
			{0.509, 0.506, 0.482, 0.5, 0.478, 0.522, 0.497, 0.556, 0.523, 0.517, 0.5, 0.569, 0.48, 0.494, 0.412, 0.509, 0.47, 0.493},
			{-0.001, 0.008, 0.02, 0.035, 0.035, 0.014, -0.016, -0.027, -0.013, 0.001, -0.014, -0.017, -0.033, -0.014, -0.008, 0.007, 0.006, 0.002},
			{0.007, 0.008, 0.018, 0.004, 0.016, 0.033, 0.048, 0.035, -0.004, -0.042, -0.086, -0.044, -0.015, 0.032, 0.005, 0.011, 0.008, 0.001},
			{-0.004, 0.001, 0.008, 0.021, 0.034, 0.036, 0.025, 0, -0.029, -0.045, -0.028, 0.04, 0.091, 0.101, 0.056, 0.016, -0.006, -0.013}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.0646, -0.0653, 0.5283, -0.0080, -0.0107, -0.0137}, //BACK-RIGHT
		{0.0344, -0.0570, 0.5009, -0.0008, 0.0019, 0.0169},  //BACK-LEFT
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.050382, 0.042138, 0.008543, 0.000277, 0.000561, 0.004006},	//BACK-RIGHT
		{0.032978, 0.052047, 0.001137, 0.000363, 0.001049, 0.001517}//BACK-LEFT
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = BACK_L;
	else
		result_ = BACK_R;

	return result_;
}




int assignDB_RIGHT_FB ()	{

	int result_;
	printf ("\nassign DB RIGHT-frontBack\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0.035, 0.244, 0.425, 0.387, 0.016, -0.348, -0.447, -0.312, -0.133, 0.012, 0.102, 0.11, 0.083, 0.051, 0.068, 0.057, 0.041, 0.019},
			{-0.071, -0.023, 0.003, 0.002, -0.098, -0.158, -0.067, 0.121, 0.285, 0.254, 0.014, -0.286, -0.398, -0.324, -0.162, -0.098, -0.07, -0.07},
			{0.53, 0.541, 0.515, 0.508, 0.487, 0.551, 0.638, 0.687, 0.616, 0.54, 0.416, 0.36, 0.38, 0.432, 0.507, 0.493, 0.515, 0.528},
			{0.002, -0.007, 0.003, 0.01, 0.016, -0.004, -0.017, -0.002, 0.022, 0.044, 0.026, -0.019, -0.042, -0.036, -0.009, -0.005, -0.003, -0.001},
			{0.002, 0.014, 0.013, -0.01, -0.037, -0.043, -0.008, 0.009, 0.016, 0.01, 0.016, 0.023, 0, -0.007, -0.019, -0.005, -0.004, 0},
			{0.007, 0.012, -0.022, -0.058, -0.103, -0.078, -0.036, 0.02, 0.04, 0.034, 0.007, -0.019, -0.027, -0.013, 0, 0.001, -0.004, -0.004}
		},
		{
			{0.053, 0.168, 0.353, 0.446, 0.245, -0.164, -0.457, -0.397, -0.147, 0.046, 0.112, 0.107, 0.122, 0.097, 0.069, 0.009, -0.001, 0.007},
			{-0.005, -0.022, 0.024, 0.085, 0.025, -0.108, -0.259, -0.326, -0.396, -0.389, -0.177, 0.115, 0.384, 0.373, 0.233, 0.02, -0.052, -0.064},
			{0.523, 0.525, 0.546, 0.539, 0.546, 0.471, 0.442, 0.411, 0.457, 0.456, 0.523, 0.521, 0.568, 0.544, 0.574, 0.551, 0.519, 0.503},
			{0.001, 0.002, 0.007, 0.013, -0.004, -0.017, -0.024, -0.007, -0.012, -0.025, -0.028, -0.021, 0.003, 0.014, 0.019, 0.001, -0.011, -0.01},
			{-0.007, -0.015, -0.025, -0.023, 0.007, 0.049, 0.05, 0.013, -0.037, -0.058, -0.033, 0.008, 0.045, 0.029, 0.006, -0.009, -0.004, -0.01},
			{0.004, 0.001, -0.015, -0.061, -0.11, -0.124, -0.07, 0.011, 0.077, 0.092, 0.075, 0.04, 0.014, -0.009, -0.021, -0.022, -0.012, -0.008}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.0228, -0.0637, 0.5136, -0.0012, -0.0017, -0.0135}, //RIGHT-front
		{0.0371, -0.0299, 0.5122, -0.0055, -0.0008, -0.0077} 	//RIGHT-back
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.050592418, 0.030769412, 0.006952261, 0.000431359, 0.000316118, 0.001367441},	//RIGHT-front
		{0.050591163, 0.051681232, 0.002125324, 0.000199441, 0.000913, 0.00343706}	//RIGHT-back
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = RIGHT_F;
	else
		result_ = RIGHT_B;

	return result_;
}





int assignDB_LEFT_FB ()	{

	int result_;
	printf ("\nassign DB LEFT-frontBack\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
				-0.045, -0.28, -0.496, -0.287, 0.18, 0.546, 0.413, 0.158, 0, -0.035, 0.035, 0.096, 0.083, -0.005, -0.073, -0.071, -0.023, -0.005,
				0.032, 0.051, -0.168, -0.284, -0.229, -0.009, 0.133, 0.06, 0.205, 0.427, 0.409, 0.033, -0.432, -0.446, -0.254, -0.05, 0, 0.021,
				0.505, 0.404, 0.434, 0.487, 0.564, 0.542, 0.52, 0.56, 0.628, 0.552, 0.467, 0.466, 0.52, 0.571, 0.49, 0.483, 0.511, 0.514,
				-0.014, -0.013, -0.005, 0.005, 0.002, -0.005, -0.01, -0.009, -0.007, 0.016, 0.032, 0.014, -0.027, -0.033, -0.007, 0.019, 0.012, 0.006,
				0.014, 0.016, -0.023, -0.024, -0.006, 0.022, 0.016, -0.002, 0.013, 0.022, -0.011, -0.01, -0.002, 0.022, 0.01, -0.02, -0.014, -0.011,
				0.012, -0.006, 0.026, 0.102, 0.149, 0.126, 0.029, -0.011, -0.002, 0.003, -0.035, -0.095, -0.09, -0.038, 0.009, 0.018, 0.017, 0.012

		},
		{
			{-0.032, -0.108, -0.303, -0.415, -0.231, 0.111, 0.384, 0.338, 0.212, 0.097, 0.037, 0.003, -0.047, -0.034, -0.023, -0.016, -0.049, -0.048},
			{-0.022, 0.01, -0.043, -0.14, -0.128, -0.061, 0.049, -0.016, -0.114, -0.234, -0.325, -0.223, -0.029, 0.228, 0.291, 0.211, 0.062, -0.014},
			{0.512, 0.502, 0.521, 0.568, 0.571, 0.515, 0.502, 0.488, 0.535, 0.514, 0.521, 0.485, 0.509, 0.455, 0.49, 0.477, 0.549, 0.55},
			{-0.004, 0.001, -0.001, -0.001, -0.005, -0.011, -0.006, -0.001, 0.008, 0.016, 0.022, 0.019, -0.002, -0.004, 0.002, 0.004, -0.006, -0.012},
			{0.002, 0, -0.003, 0, 0.016, 0.016, 0.003, -0.019, -0.023, -0.022, -0.019, 0.002, 0.032, 0.049, 0.023, 0.002, -0.015, -0.006},
			{-0.008, -0.012, 0, 0.044, 0.095, 0.109, 0.072, 0.019, -0.014, -0.028, -0.029, -0.026, -0.014, -0.001, -0.003, -0.008, -0.013, -0.002}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			0.01061, -0.02783, 0.51211, -0.00133, 0.00067, 0.01256,
		{-0.0069, -0.0277, 0.5147, 0.0011, 0.0021, 0.0101}
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			0.05661, 0.05989, 0.00285, 0.00027, 0.00027, 0.00401,
		{0.039284, 0.025894, 0.000969, 0.000092, 0.000377, 0.001748}
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = LEFT_F;
	else
		result_ = LEFT_B;

	return result_;
}




int assignDB_UP_RL ()	{

	int result_;
	printf ("\nassign DB UP-RightLeft\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0.01, 0.009, 0.023, 0.005, -0.021, -0.038, 0.005, 0.092, 0.178, 0.255, 0.294, 0.265, 0.117, -0.102, -0.238, -0.246, -0.152, -0.083},
			{-0.035, -0.034, -0.016, -0.039, -0.1, -0.138, -0.092, 0.005, 0.045, 0.039, 0.002, -0.016, -0.04, -0.047, -0.01, 0.028, 0.072, 0.078},
			{0.519, 0.591, 0.758, 0.834, 0.747, 0.473, 0.232, 0.131, 0.225, 0.383, 0.501, 0.534, 0.539, 0.515, 0.509, 0.501, 0.499, 0.484},
			{-0.011, -0.014, 0, 0.024, 0.045, 0.05, 0.029, 0.009, -0.014, -0.014, -0.003, 0.016, 0.034, 0.027, 0.013, -0.001, -0.003, -0.006},
			{0, -0.003, -0.003, 0.002, 0.011, 0.023, 0.018, 0.001, -0.026, -0.037, -0.036, -0.026, -0.011, 0.004, 0.014, 0.011, 0.01, 0.006},
			{-0.001, 0.003, 0.005, 0.007, 0.001, 0.005, 0.016, 0.012, -0.003, -0.029, -0.042, -0.06, -0.076, -0.087, -0.073, -0.045, -0.018, -0.004}
		},
		{
			{-0.009, -0.002, 0.022, 0.042, 0.047, 0.025, 0.03, 0.014, -0.021, -0.119, -0.26, -0.36, -0.243, 0.045, 0.329, 0.391, 0.292, 0.175},
			{-0.025, -0.012, -0.05, -0.083, -0.066, -0.036, 0.017, 0.007, 0.026, 0.026, 0.003, -0.012, -0.017, -0.047, -0.122, -0.134, -0.088, 0.002},
			{0.554, 0.716, 0.873, 0.888, 0.52, 0.161, 0.018, 0.203, 0.437, 0.568, 0.605, 0.539, 0.484, 0.375, 0.47, 0.483, 0.555, 0.482},
			{-0.008, -0.022, -0.012, 0.046, 0.084, 0.077, 0.016, -0.01, -0.024, -0.016, -0.012, -0.008, -0.027, -0.045, -0.04, -0.011, 0.008, 0.012},
			{-0.002, -0.015, -0.035, -0.024, 0.022, 0.042, 0.029, -0.014, -0.017, -0.019, -0.017, -0.007, 0.002, -0.003, -0.026, -0.02, -0.004, 0.01},
			{0.001, 0.014, 0.015, 0.006, -0.003, -0.006, 0.001, -0.009, -0.007, -0.009, 0.012, 0.043, 0.075, 0.072, 0.053, 0.027, 0.018, 0.003}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.02072, -0.01656, 0.49861, 0.01006, -0.00233, -0.02161},
		{0.02211, -0.03394, 0.49617, 0.00044, -0.00544, 0.01700}
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.02518, 0.00332, 0.03229, 0.00043, 0.00032, 0.00114},
		{0.03808, 0.00235, 0.04802, 0.00129, 0.00041, 0.00072}
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = UP_R;
	else
		result_ = UP_L;

	return result_;
}


int assignDB_DOWN_RL ()	{

	int result_;
	printf ("\nassign DB DOWN-RightLeft\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0, -0.008, -0.016, -0.015, 0.013, 0.086, 0.2, 0.316, 0.371, 0.303, 0.123, -0.143, -0.306, -0.33, -0.217, -0.112, -0.049, -0.024},
			{0.034, -0.001, -0.021, 0.002, -0.006, -0.05, -0.109, -0.077, -0.014, 0.004, 0.006, -0.068, -0.072, -0.07, -0.009, 0.009, 0.012, 0.022},
			{0.487, 0.412, 0.241, 0.08, 0.2, 0.528, 0.883, 0.907, 0.73, 0.529, 0.434, 0.42, 0.476, 0.478, 0.506, 0.482, 0.497, 0.502},
			{-0.001, 0.007, 0.005, -0.023, -0.064, -0.079, -0.053, 0.003, 0.044, 0.068, 0.044, 0.013, -0.012, -0.015, -0.006, 0, 0.001, 0.002},
			{0.013, 0.004, 0.035, 0, -0.032, -0.086, -0.034, 0.019, 0.051, 0.015, 0.007, -0.003, 0.014, 0.013, 0.014, 0.006, 0, -0.001},
			{0.011, 0.013, 0.021, 0.017, 0.012, 0.001, 0.003, -0.004, -0.025, -0.051, -0.085, -0.1, -0.084, -0.044, -0.007, 0.005, 0.01, 0.007}
		},
		{
			{-0.018, -0.033, -0.067, -0.049, 0.018, 0.069, 0.064, -0.024, -0.135, -0.274, -0.315, -0.115, 0.153, 0.349, 0.306, 0.184, 0.071, 0.02},
			{-0.012, -0.047, -0.036, -0.048, -0.046, -0.104, -0.19, -0.202, -0.218, -0.19, -0.187, -0.159, -0.096, -0.081, -0.055, -0.087, -0.125, -0.16},
			{0.485, 0.426, 0.235, -0.025, 0.036, 0.39, 0.833, 0.905, 0.778, 0.569, 0.508, 0.466, 0.451, 0.418, 0.424, 0.457, 0.496, 0.504},
			{0.001, 0.003, 0.011, -0.022, -0.075, -0.12, -0.091, -0.037, 0.009, 0.019, 0.029, 0.025, 0.033, 0.024, 0.009, -0.011, -0.021, -0.009},
			{0.015, 0.02, 0.033, 0.017, -0.02, -0.078, -0.058, -0.018, 0.018, 0.002, -0.02, -0.003, 0, -0.006, -0.011, -0.017, -0.005, -0.018},
			{0.001, 0.005, -0.004, -0.004, -0.006, -0.01, -0.02, -0.025, -0.007, 0.019, 0.053, 0.076, 0.057, 0.037, 0.004, 0, -0.012, -0.006}

		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.01067, -0.02267, 0.48844, -0.00367, 0.00194, -0.01667},
		{0.01133, -0.11350, 0.46422, -0.01239, -0.00828, 0.00878}
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.03977, 0.00167, 0.04224, 0.00133, 0.00087, 0.00152},
		{0.02939, 0.00443, 0.05476, 0.00187, 0.00073, 0.00080}

	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = DOWN_R;
	else
		result_ = DOWN_L;

	return result_;
}


int assignDB_RIGHT_UD ()	{

	int result_;
	printf ("\nassign DB RIGHT-UpDown\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0.01, 0.08, 0.28, 0.374, 0.148, -0.248, -0.422, -0.242, -0.035, 0.04, 0.016, 0.019, 0.023, 0.043, 0.031, 0.018, 0.009, 0.015},
			{-0.057, -0.084, -0.064, -0.062, -0.112, -0.214, -0.233, -0.21, -0.145, -0.143, -0.136, -0.019, 0.028, 0.116, 0.069, 0.069, 0.048, 0.035},
			{0.524, 0.512, 0.578, 0.558, 0.44, 0.427, 0.537, 0.825, 0.863, 0.791, 0.584, 0.295, 0.178, 0.134, 0.263, 0.341, 0.437, 0.519},
			{-0.008, -0.009, -0.009, 0.007, 0.014, 0.001, -0.013, -0.019, 0.018, 0.062, 0.096, 0.097, 0.058, 0.025, -0.007, -0.016, -0.02, -0.016},
			{0.004, 0.008, 0.015, 0.032, 0.014, -0.025, -0.052, -0.037, -0.01, -0.022, -0.01, 0.02, 0.03, 0.027, 0.001, 0, -0.011, -0.01},
			{0.008, 0.011, -0.004, -0.053, -0.114, -0.119, -0.062, 0.012, 0.036, 0.016, 0.008, 0.011, 0.015, 0.001, -0.01, -0.013, -0.012, -0.008}
		},
		{
			{0.011, 0.109, 0.278, 0.387, 0.342, 0.106, -0.187, -0.339, -0.279, -0.129, 0.017, 0.09, 0.144, 0.11, 0.079, 0.069, 0.073, 0.061},
			{0, -0.004, -0.02, 0.035, 0.068, 0.079, -0.031, -0.107, -0.147, -0.104, -0.044, -0.068, -0.063, -0.089, -0.059, -0.071, -0.102, -0.108},
			{0.52, 0.516, 0.542, 0.56, 0.556, 0.508, 0.488, 0.486, 0.427, 0.229, 0.176, 0.415, 0.733, 0.828, 0.679, 0.571, 0.518, 0.494},
			{0.008, 0.007, 0.002, -0.002, 0.012, 0.014, -0.004, -0.02, -0.024, -0.024, -0.059, -0.086, -0.069, -0.034, -0.006, -0.005, 0.003, 0.006},
			{0, -0.005, -0.005, -0.014, -0.023, -0.032, -0.032, -0.019, -0.005, 0.014, 0, -0.019, -0.022, 0.007, 0.016, 0.009, -0.003, 0.003},
			{-0.005, -0.003, -0.011, -0.035, -0.076, -0.114, -0.118, -0.081, -0.021, 0.018, 0.031, 0.032, 0.023, 0.016, 0.005, 0.001, -0.003, -0.002}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		{0.00883, -0.06189, 0.48922, 0.01450, -0.00144, -0.01539},
		{0.05233, -0.04639, 0.51367, -0.01561, -0.00722, -0.01906}
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		{0.03240, 0.01139, 0.04194, 0.00147, 0.00054, 0.00190},
		{0.03668, 0.00398, 0.02332, 0.00086, 0.00022, 0.00222}
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = RIGHT_U;
	else
		result_ = RIGHT_D;

	return result_;
}


int assignDB_LEFT_UD ()	{

	int result_;
	printf ("\nassign DB Left-UpDown\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
				0.001, -0.073, -0.286, -0.4, -0.255, 0.11, 0.353, 0.328, 0.203, 0.11, 0.087, 0.064, 0.046, 0.013, 0.004, 0, 0.02, 0.035,
				0.001, -0.001, -0.082, -0.146, -0.148, -0.043, 0.013, -0.032, -0.087, -0.101, 0.008, 0.061, 0.105, 0.051, 0.054, 0.047, 0.098, 0.094,
				0.501, 0.523, 0.479, 0.449, 0.478, 0.492, 0.551, 0.666, 0.865, 0.897, 0.605, 0.274, 0.086, 0.132, 0.278, 0.403, 0.504, 0.535,
				-0.002, -0.005, -0.005, -0.003, 0.001, -0.003, -0.012, -0.008, 0.029, 0.085, 0.096, 0.072, 0.019, 0.002, -0.008, -0.009, -0.011, -0.01,
				0.002, 0.005, 0.014, -0.005, -0.011, -0.019, -0.018, -0.031, -0.037, -0.01, 0.025, 0.028, 0.022, -0.002, -0.011, -0.017, -0.012, -0.006,
				-0.004, -0.012, -0.006, 0.03, 0.061, 0.068, 0.036, 0.007, -0.004, -0.001, 0.004, -0.003, -0.013, -0.018, -0.01, -0.001, 0.006, 0.005
		},
		{
			{-0.044, -0.19, -0.395, -0.417, -0.171, 0.189, 0.385, 0.375, 0.244, 0.025, -0.05, -0.06, 0.018, 0.01, -0.016, -0.008, -0.009, 0.012},
			{0.001, -0.034, -0.144, -0.205, -0.161, -0.005, 0.066, 0.064, -0.015, -0.104, -0.013, -0.047, -0.04, -0.204, -0.222, -0.201, -0.174, -0.133},
			{0.517, 0.504, 0.482, 0.492, 0.478, 0.47, 0.493, 0.515, 0.416, 0.084, 0.003, 0.29, 0.73, 0.927, 0.788, 0.656, 0.523, 0.482},
			{0, 0.004, 0.008, 0.002, -0.005, -0.022, -0.02, -0.003, 0.029, 0.06, -0.03, -0.091, -0.134, -0.061, -0.011, 0.009, 0.018, 0.011},
			{0.007, 0.011, 0.003, 0.003, -0.007, -0.011, -0.013, 0.001, 0.033, 0.031, 0.004, -0.044, -0.042, -0.033, -0.008, -0.005, 0.004, 0.005},
			{-0.01, -0.018, 0.006, 0.062, 0.112, 0.099, 0.049, -0.009, -0.038, -0.043, -0.016, -0.001, 0.002, -0.011, -0.009, -0.006, -0.001, 0.001}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
			0.02000, -0.00600, 0.48433, 0.01267, -0.00461, 0.00806,
			0.00444, -0.01417, 0.50989, 0.00411, 0.00528, 0.00128,
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
			0.03636, 0.00653, 0.04409, 0.00121, 0.00033, 0.00061,
		{0.03139, 0.00457, 0.03045, 0.00029, 0.00043, 0.00170}
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = LEFT_U;
	else
		result_ = LEFT_D;

	return result_;
}







int assignDB_UP_FB ()	{

	int result_;
	printf ("\nassign DB UP-FrontBack\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{-0.015, -0.023, -0.033, -0.035, -0.05, -0.057, -0.043, -0.02, -0.001, -0.007, 0.01, 0.069, 0.117, 0.121, 0.054, 0.007, -0.003, 0.012},
			{-0.019, -0.021, -0.056, -0.068, -0.093, -0.05, -0.008, 0.113, 0.197, 0.28, 0.27, 0.179, -0.016, -0.207, -0.289, -0.242, -0.148, -0.082},
			{0.575, 0.679, 0.779, 0.785, 0.599, 0.348, 0.189, 0.207, 0.345, 0.431, 0.484, 0.481, 0.504, 0.532, 0.55, 0.531, 0.538, 0.542},
			{-0.035, -0.03, 0.004, 0.034, 0.056, 0.044, 0.021, -0.008, -0.018, -0.007, 0.01, 0.012, -0.013, -0.044, -0.044, -0.018, 0.007, 0.012},
			{0.005, 0.003, -0.003, 0.004, 0.017, 0.017, 0.002, -0.014, -0.022, -0.025, -0.033, -0.035, -0.014, 0.01, 0.027, 0.015, 0.006, 0.008},
			{0.007, 0.005, 0.011, 0.013, 0.017, 0.013, 0.016, 0.017, 0.011, 0, -0.016, -0.015, -0.029, -0.033, -0.04, -0.024, -0.007, 0.002}
		},
		{
			{0.026, 0.024, 0.01, 0.002, 0.017, 0, -0.017, -0.028, 0.018, 0.05, 0.071, 0.076, 0.067, 0.004, -0.068, -0.092, -0.057, -0.023},
			{-0.019, 0, 0, -0.007, -0.008, -0.023, -0.054, -0.083, -0.12, -0.212, -0.357, -0.349, -0.152, 0.154, 0.33, 0.324, 0.216, 0.105},
			{0.566, 0.649, 0.744, 0.784, 0.752, 0.503, 0.273, 0.174, 0.299, 0.449, 0.53, 0.541, 0.478, 0.449, 0.444, 0.492, 0.522, 0.529},
			{-0.004, -0.017, -0.006, 0.017, 0.036, 0.02, 0, -0.014, -0.013, -0.015, -0.003, 0.007, 0.015, 0.019, 0.016, 0.009, 0.004, 0.003},
			{0.001, 0.015, 0.015, 0.008, 0.013, 0.013, 0.008, -0.013, -0.017, -0.014, -0.002, 0.013, 0.019, 0.017, 0.006, 0.007, 0.003, 0.003},
			{-0.003, 0.002, 0.008, 0.012, 0.016, 0.011, 0.006, 0.003, 0.001, 0.004, 0.009, 0.025, 0.015, -0.006, -0.032, -0.027, -0.015, -0.006}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		0.05144, -0.03989, 0.50944, -0.00233, -0.00500, 0.00106,
		-0.01233, -0.05317, 0.51672, -0.01233, 0.01322, -0.00661
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		0.00276, 0.02734, 0.02640, 0.00083, 0.00033, 0.00035,
		0.00220, 0.03730, 0.02585, 0.00021, 0.00012, 0.00021
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = UP_B;
	else
		result_ = UP_F;

	return result_;
}


int assignDB_DOWN_FB ()	{

	int result_;
	printf ("\nassign DB DOWN-FrontBack\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{-0.006, -0.007, -0.034, -0.039, 0.025, 0.116, 0.163, 0.12, 0.057, 0.003, -0.067, -0.001, 0.143, 0.216, 0.131, 0.021, 0.026, 0.059},
			{0.021, 0.002, -0.026, -0.063, -0.068, -0.033, -0.008, -0.005, -0.019, 0.069, 0.297, 0.509, 0.175, -0.316, -0.646, -0.421, -0.15, -0.036},
			{0.509, 0.427, 0.197, 0.011, 0.242, 0.633, 0.952, 0.842, 0.675, 0.589, 0.549, 0.402, 0.497, 0.604, 0.656, 0.519, 0.392, 0.474},
			{0.004, 0.018, 0.044, 0.021, -0.023, -0.072, -0.068, -0.04, -0.013, -0.001, 0.042, 0.076, 0.055, -0.012, -0.049, -0.028, 0.003, 0.001},
			{0.003, 0.017, 0.02, -0.013, -0.061, -0.06, -0.026, 0.027, 0.025, 0.023, 0.005, -0.001, -0.045, -0.008, -0.004, 0.023, -0.01, -0.005},
			{-0.002, 0.001, 0.005, 0.012, 0.025, 0.028, 0.018, 0.003, -0.003, 0.008, 0.012, 0.003, -0.016, -0.051, -0.034, -0.016, 0.018, 0.008}
		},
		{
			{-0.022, -0.045, -0.074, -0.032, 0.061, 0.134, 0.127, 0.067, 0.04, 0.017, 0.008, -0.007, -0.052, -0.077, -0.102, -0.088, -0.091, -0.086},
			{-0.018, -0.026, -0.055, -0.041, -0.044, -0.05, -0.078, -0.117, -0.181, -0.308, -0.338, -0.201, 0.144, 0.275, 0.249, 0.017, -0.073, -0.112},
			{0.464, 0.335, 0.182, 0.206, 0.478, 0.798, 0.883, 0.746, 0.568, 0.449, 0.431, 0.481, 0.56, 0.563, 0.556, 0.536, 0.553, 0.512},
			{0.009, 0.024, 0.003, -0.034, -0.071, -0.061, -0.031, -0.002, 0.017, 0.027, 0.029, 0, -0.026, -0.048, -0.033, -0.021, -0.004, 0},
			{-0.003, -0.003, -0.008, -0.022, -0.037, -0.026, 0.004, 0.025, 0.02, 0.015, 0.006, 0.036, 0.067, 0.081, 0.061, 0.02, 0.007, -0.005},
			{-0.002, 0, 0.012, 0.021, 0.017, 0.003, -0.011, -0.015, -0.017, -0.021, -0.017, -0.006, -0.001, -0.01, -0.026, -0.028, -0.015, -0.003}

		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		0.01661, -0.00856, 0.47361, 0.00439, -0.00911, -0.00078,
		0.00483, -0.07300, 0.50317, -0.01317, -0.00361, 0.00089
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		0.00628, 0.06374, 0.04933, 0.00168, 0.00077, 0.00040,
		0.00547, 0.02575, 0.03146, 0.00089, 0.00102, 0.00019
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = DOWN_B;
	else
		result_ = DOWN_F;

	return result_;
}


int assignDB_FRONT_UD ()	{

	int result_;
	printf ("\nassign DB FRONT-UpDown\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{-0.011, -0.025, -0.026, -0.01, 0.046, 0.027, -0.026, -0.065, 0.008, 0.057, 0.055, -0.01, -0.009, 0.019, 0.056, 0.07, 0.073, 0.07},
			{0.001, 0.157, 0.339, 0.439, 0.245, -0.111, -0.407, -0.385, -0.253, -0.185, -0.179, -0.113, 0.02, 0.079, 0.073, 0.065, 0.034, 0.027},
			{0.513, 0.499, 0.532, 0.53, 0.488, 0.454, 0.517, 0.717, 0.882, 0.962, 0.675, 0.248, -0.02, -0.015, 0.21, 0.336, 0.477, 0.52},
			{-0.007, -0.008, 0.004, 0.027, 0.039, -0.005, -0.047, -0.072, -0.029, 0.038, 0.089, 0.086, 0.027, -0.008, -0.023, -0.012, -0.012, -0.008},
			{0.002, 0.012, -0.011, -0.018, -0.018, 0.019, 0.016, -0.006, -0.056, -0.052, -0.012, 0.018, 0.017, -0.017, -0.023, -0.023, -0.011, -0.001},
			{0.015, 0.014, 0.01, 0.001, -0.017, -0.026, -0.016, 0.009, 0.018, 0.007, 0.003, 0, 0.005, -0.012, -0.011, -0.013, -0.002, 0.001}
		},
		{
			{-0.051, -0.078, -0.088, -0.05, -0.005, 0.014, -0.016, -0.008, 0.008, 0.05, 0.063, 0.102, 0.079, 0.045, -0.011, -0.002, 0.013, 0.022},
			{0.007, 0.101, 0.219, 0.319, 0.201, -0.1, -0.386, -0.479, -0.32, -0.092, 0.045, 0.042, -0.117, -0.208, -0.226, -0.15, -0.091, -0.079},
			{0.502, 0.508, 0.487, 0.523, 0.472, 0.501, 0.474, 0.485, 0.357, 0.233, 0.184, 0.467, 0.705, 0.85, 0.693, 0.587, 0.522, 0.507},
			{-0.001, -0.004, 0, 0, 0.005, -0.005, -0.026, -0.025, -0.013, 0.013, -0.028, -0.067, -0.085, -0.037, 0.003, 0.017, 0.01, 0.006},
			{0.002, 0.001, -0.004, -0.009, -0.006, -0.019, -0.019, -0.021, 0.009, 0.006, -0.021, -0.042, -0.014, 0.024, 0.037, 0.009, 0.001, 0.001},
			{-0.001, 0.004, 0.008, 0.01, 0.008, -0.008, -0.009, -0.003, 0.02, 0.03, 0.026, 0.001, -0.018, -0.028, -0.016, -0.006, -0.001, -0.001}
		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		0.01050, 0.00589, 0.47394, 0.01111, -0.00239, -0.00056,
		-0.00394, -0.05089, 0.51444, -0.00994, 0.00078, -0.00611
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		0.00173, 0.05167, 0.06707, 0.00169, 0.00048, 0.00016,
		0.00265, 0.04427, 0.02381, 0.00076, 0.00033, 0.00022
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = FRONT_D;
	else
		result_ = FRONT_U;

	return result_;
}


int assignDB_BACK_UD ()	{

	int result_;
	printf ("\nassign DB Back-UpDown\n");

	float db_sample [ELE_OF_DB][AXIS_NUM][WMA_SAMPLE_NUM] = {
		{
			{0, 0.017, 0.041, 0.063, 0.026, 0.011, -0.01, -0.004, -0.049, -0.039, -0.053, -0.029, -0.007, 0.055, 0.084, 0.051, 0.02, 0.012},
			{-0.087, -0.184, -0.304, -0.303, -0.177, 0.106, 0.324, 0.358, 0.187, -0.001, -0.079, -0.045, 0.074, 0.095, 0.094, 0.003, 0.011, 0.034},
			{0.518, 0.538, 0.487, 0.527, 0.421, 0.453, 0.394, 0.573, 0.757, 0.925, 0.799, 0.499, 0.211, 0.16, 0.208, 0.287, 0.347, 0.427},
			{0.01, 0.02, 0.029, 0.032, 0.023, -0.013, -0.041, -0.059, -0.042, -0.016, 0.031, 0.068, 0.079, 0.056, 0.029, 0.008, -0.003, -0.011},
			{-0.011, -0.01, -0.003, 0.006, 0.017, 0.007, 0.028, 0.01, 0.013, -0.007, -0.025, -0.029, -0.041, -0.028, -0.008, 0.004, 0.02, 0.014},
			{-0.003, -0.003, 0.008, 0.012, 0.024, 0.006, -0.011, -0.031, -0.022, 0.009, 0.029, 0.03, 0.009, -0.012, -0.02, -0.019, -0.01, -0.006}
		},
		{
			-0.021, -0.034, -0.008, 0.056, 0.08, 0.05, -0.006, -0.014, -0.02, -0.026, 0.001, 0.076, 0.06, 0.007, -0.053, 0.005, 0.046, 0.053,
			-0.063, -0.148, -0.309, -0.365, -0.309, -0.018, 0.246, 0.427, 0.387, 0.256, 0.081, -0.111, -0.267, -0.33, -0.29, -0.217, -0.159, -0.12,
			0.503, 0.508, 0.523, 0.561, 0.521, 0.493, 0.406, 0.425, 0.337, 0.203, 0.008, 0.272, 0.623, 0.953, 0.829, 0.711, 0.554, 0.47,
			0, 0.006, 0.006, 0.001, -0.003, -0.007, -0.017, -0.009, -0.005, 0.007, -0.025, -0.105, -0.103, -0.066, 0.017, 0.012, 0.005, 0.002,
			-0.002, -0.014, -0.026, 0.006, 0.037, 0.056, 0.026, 0.004, -0.006, -0.011, -0.014, -0.009, -0.027, -0.025, -0.032, 0.001, 0.017, 0.023,
			0, -0.004, -0.008, -0.009, 0.02, 0.041, 0.058, 0.031, 0.003, -0.029, -0.048, -0.05, -0.042, -0.024, -0.008, 0.004, 0.008, 0.002

		}
	};
	float db_average [ELE_OF_DB][AXIS_NUM] = {
		0.01050, 0.00589, 0.47394, 0.01111, -0.00239, -0.00056,
		0.01400, -0.07272, 0.49444, -0.01578, 0.00022, -0.00306
	};

	float db_cov [ELE_OF_DB][AXIS_NUM] = {
		0.00151, 0.03345, 0.04177, 0.00141, 0.00037, 0.00031,
		0.00169, 0.06372, 0.04732, 0.00136, 0.00057, 0.00086
	};

	if (result_ = crossCorrelation(db_sample, db_average, db_cov))
		result_ = BACK_D;
	else
		result_ = BACK_U;

	return result_;
}




/*
struct minMax	{
	int min_;
	int max_;
	int min_seq;
	int max_seq;
	int gap_;
	int maxFlag;
	int minFlag;

};

*/


unsigned char gestureRecognition (int16_t sensor [AXIS_NUM][SAMPLE_NUM])	{

	//struct minMax mm [AXIS_NUM];


	int min_ [AXIS_NUM] = {10000,10000,30000,10000,10000,10000};
	int max_ [AXIS_NUM] = {-10000, -10000,-1000,-1000,-1000,-1000};

	int min_seq [AXIS_NUM]= {-1,-1,-1,-1,-1,-1};
	int max_seq [AXIS_NUM]= {-1,-1,-1,-1,-1,-1};

	int gaps [AXIS_NUM] = {0,0,0,0,0,0};
	int maxFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	int minFlag [AXIS_NUM] = {0,0,0,0,0,0};	//# of sample upto 32
	unsigned char Motionflag_ = 0;
	int nLoop, nLoop2;
	int result_ = 0 ;

	memset (biggestValue, 0, sizeof (biggestValue));
	memset (WEIGHTED_AXIS, 2, sizeof (WEIGHTED_AXIS));

	normalizingFunction (sensor);

	//	printf ("<INPUT>\n");
	/*for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < SAMPLE_NUM; nLoop2 ++)	{
			printf ("%d,", sensor [nLoop][nLoop2] );
		}
		printf ("\n");
	}
	//printf ("\n");
*/

#ifdef WMA_FACTOR
	weightedMovingAverage (sensor);
#endif


	//	printf ("<INPUT>\n");
	for (nLoop = 0; nLoop < AXIS_NUM; nLoop ++)	{
		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM; nLoop2 ++)	{
			printf ("%d\t", WMA_SENSOR [nLoop][nLoop2] );
		}
		printf ("\n");
	}
	printf ("\n");



	char temp_flag = 0;

	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{

		for (nLoop2 = 0; nLoop2 < WMA_SAMPLE_NUM; nLoop2 ++)	{

			if (min_[nLoop] > WMA_SENSOR [nLoop][nLoop2])	{
				min_[nLoop] = WMA_SENSOR [nLoop][nLoop2];
				minFlag [nLoop] |= 0x1;
				min_seq [nLoop] = nLoop2;

			} else if (max_[nLoop] < WMA_SENSOR [nLoop][nLoop2])	{
				max_[nLoop] = WMA_SENSOR [nLoop][nLoop2];
				maxFlag [nLoop] |= 0x1;
				max_seq [nLoop] = nLoop2;
			}
			minFlag[nLoop] = minFlag[nLoop] << 1;
			maxFlag[nLoop] = maxFlag[nLoop] << 1;

		}

		if (min_seq [nLoop] > max_seq [nLoop]){
			int tempInt = min_seq [nLoop];
			min_seq [nLoop] = max_seq [nLoop];
			max_seq [nLoop] = tempInt;
		}
		printf ("%d: %d & %d\n", nLoop, min_seq [nLoop],max_seq [nLoop]);

		gaps [nLoop] = max_ [nLoop] - min_ [nLoop];
		//printf ("%d: %d /  ", nLoop, gaps [nLoop]);

		if (gaps [nLoop] > 400)	{
			Motionflag_ |= 0x1;
			temp_flag ++;
			WEIGHTED_AXIS [nLoop] = 90;
		}
		Motionflag_ = Motionflag_ << 1;

	} //for

	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{
		WEIGHTED_AXIS [nLoop] /= temp_flag;
	}


//	printf ("1. motionflag: %x\n", Motionflag_ & 0xff);

	if (!Motionflag_ )	{
		result_ = NONE;
	//else if (Motionflag_ == 32)
	}
	else {

		int temp_result [NUM_OF_DB], max=0, max_gest=0;
		memset (temp_result, 0, sizeof(temp_result));

		if ((Motionflag_ & 0x70) == 0x70)	{	//find two axis that have biggest gap
			int temp_max_flag = gaps [0] > gaps [1] ? 1 : 0;

			if (gaps [temp_max_flag] > gaps [2])	{
				Motionflag_ &= 0x6F;
			}
			else if (temp_max_flag)	{
				Motionflag_ &= 0x5F;
			}
			else
				Motionflag_ &= 0x3F;
		}
		//printf ("2. motionflag: %x\n", Motionflag_ & 0xff);

		switch (Motionflag_ & 0x70)	{
		case 0x20:	//FRONT
			result_ = assignDB_FRONT ();
			break;
		case 0x40:		//SIDE
			result_ = assignDB_RIGHT ();
			break;
		case 0x10:	//UP
			result_ = assignDB_UP ();
			break;
		case 0x50:

			if (((max_seq [ACC_X] - min_seq [ACC_Z] > CIRCLE_THRESH ) && (min_seq [ACC_X] <= min_seq [ACC_Z] ))
					|| ((max_seq [ACC_Z] - min_seq [ACC_X] > CIRCLE_THRESH ) && (min_seq [ACC_Z] <= min_seq [ACC_X] )))	{

				result_ = CLOCK;
				deriveCorrelation ();
				result_ = compareSelfCorrleation (CLOCK);

			}
			else	{

				if (min_seq [ACC_X] >= min_seq [ACC_Z] )	{
					temp_result [1] = assignDB_UP_RL ();
					biggestValue [UP_R] = biggestValue [0];
					biggestValue [UP_L] = biggestValue [1];


					temp_result [2] = assignDB_DOWN_RL ();
					biggestValue [DOWN_R] = biggestValue [0];
					biggestValue [DOWN_L] = biggestValue [1];

					for (nLoop = UP_R; nLoop <= DOWN_L; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				} //if
				else	{

					temp_result [3] = assignDB_RIGHT_UD ();
					biggestValue [RIGHT_U] = biggestValue [0];
					biggestValue [RIGHT_D] = biggestValue [1];

					temp_result [4] = assignDB_LEFT_UD ();
					biggestValue [LEFT_U] = biggestValue [0];
					biggestValue [LEFT_D] = biggestValue [1];

					for (nLoop = RIGHT_U; nLoop <= LEFT_D; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				} //else
			} //else


			break;
		case 0x60:

			if (((max_seq [ACC_X] - min_seq [ACC_Y] > CIRCLE_THRESH ) && (min_seq [ACC_X] <= min_seq [ACC_Y] ))
					|| ((max_seq [ACC_Y] - min_seq [ACC_X] > CIRCLE_THRESH ) && (min_seq [ACC_Y] <= min_seq [ACC_X] )))	{

				/*result_ = LOW_CLOCK;
				deriveCorrelation ();
				result_ = compareSelfCorrleation (LOW_CLOCK);
				*/
				result_ = assignDB_LOW ();

			}
			else	{

				if (min_seq [ACC_X] >= min_seq [ACC_Y] )	{

					temp_result [1] = assignDB_FRONT_RL ();
					biggestValue [FRONT_R] = biggestValue [0];
					biggestValue [FRONT_L] = biggestValue [1];

					temp_result [2] = assignDB_BACK_RL ();
					biggestValue [BACK_R] = biggestValue [0];
					biggestValue [BACK_L] = biggestValue [1];

					for (nLoop = FRONT_R; nLoop <= BACK_L; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				} //if
				else	{

					temp_result [3] = assignDB_RIGHT_FB ();
					biggestValue [RIGHT_F] = biggestValue [0];
					biggestValue [RIGHT_B] = biggestValue [1];

					temp_result [4] = assignDB_LEFT_FB ();
					biggestValue [LEFT_F] = biggestValue [0];
					biggestValue [LEFT_B] = biggestValue [1];

					for (nLoop = RIGHT_F; nLoop <= LEFT_B; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for

				} //else
			} //else

			break;
		case 0x30:

			if (((max_seq [ACC_Y] - min_seq [ACC_Z] > CIRCLE_THRESH ) && (min_seq [ACC_Y] <= min_seq [ACC_Z] ))
						|| ((max_seq [ACC_Z] - min_seq [ACC_Y] > CIRCLE_THRESH ) && (min_seq [ACC_Z] <= min_seq [ACC_Y] )))	{

				/*result_ = SIDE_CLOCK;
				deriveCorrelation ();
				result_ = compareSelfCorrleation (SIDE_CLOCK);
				*/
				result_ = assignDB_SIDE ();


			}
			else	{

				if (min_seq [ACC_Y] >= min_seq [ACC_Z] )	{

					temp_result [1] = assignDB_UP_FB ();
					biggestValue [UP_F] = biggestValue [0];
					biggestValue [UP_B] = biggestValue [1];

					temp_result [2] = assignDB_DOWN_FB ();
					biggestValue [DOWN_F] = biggestValue [0];
					biggestValue [DOWN_B] = biggestValue [1];

					for (nLoop = UP_F; nLoop <= DOWN_B; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				}	//if

				else 	{
					temp_result [3] = assignDB_FRONT_UD ();
					biggestValue [FRONT_U] = biggestValue [0];
					biggestValue [FRONT_D] = biggestValue [1];

					temp_result [4] = assignDB_BACK_UD ();
					biggestValue [BACK_U] = biggestValue [0];
					biggestValue [BACK_D] = biggestValue [1];

					for (nLoop = FRONT_U; nLoop <= BACK_D; nLoop ++)	{
						if (max < biggestValue [nLoop])	{
							//printf ("max: %d -> %d\n", max, biggestValue[nLoop]);
							max = biggestValue [nLoop];
							result_ = nLoop;
							//printf ("rest: %d\n", result_);
						} //if
					}	//for
				} //else

			} //else

			break;
		default:

			temp_result [0] = assignDB_CLOCK ();
			biggestValue [CLOCK] = biggestValue [0];
			biggestValue [ANTI_CLOCK] = biggestValue [1];

			temp_result [1] = assignDB_LOW ();
			biggestValue [LOW_CLOCK] = biggestValue [0];
			biggestValue [LOW_ANTI] = biggestValue [1];

			temp_result [2] = assignDB_SIDE ();
			biggestValue [SIDE_CLOCK] = biggestValue [0];
			biggestValue [SIDE_ANTI] = biggestValue [1];

		//	printf ("\n%d %d %d\n", temp_result[0], temp_result[1], temp_result[2]);
		//	printf ("%d %d %d\n", biggestValue[temp_result[0]], biggestValue[temp_result[1]], biggestValue[temp_result[2]]);

			for (nLoop = 0; nLoop < 3; nLoop ++)	{
				if (max < biggestValue [temp_result[nLoop]])	{
					max = biggestValue [temp_result[nLoop]];
					result_ = temp_result[nLoop];
				}
			}

			//deriveCorrelation ();
			//result_ = compareSelfCorrleation (CLOCK);

			break;

		} //switch
	}	//else




	printf ("WEIGHTED: <");
	for (nLoop = ACC_X; nLoop <= GY_Z; nLoop++ )	{
		printf ("%d,", WEIGHTED_AXIS [nLoop]);
	}
	printf (">\n");




	return result_;

}







